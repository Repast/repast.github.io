<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>RepastHPC: repast::Grid&lt; T, GPType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RepastHPC
   &#160;<span id="projectnumber">2.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>repast</b></li><li class="navelem"><a class="el" href="classrepast_1_1_grid.html">Grid</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classrepast_1_1_grid-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">repast::Grid&lt; T, GPType &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Abstract interface for Grids and ContinuousSpaces.  
 <a href="classrepast_1_1_grid.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_grid_8h_source.html">Grid.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for repast::Grid&lt; T, GPType &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classrepast_1_1_grid.png" usemap="#repast::Grid_3C_20T_2C_20GPType_20_3E_map" alt=""/>
  <map id="repast::Grid_3C_20T_2C_20GPType_20_3E_map" name="repast::Grid&lt; T, GPType &gt;_map">
<area href="classrepast_1_1_projection.html" title="Abstract base class for all Projections. " alt="repast::Projection&lt; T &gt;" shape="rect" coords="271,56,804,80"/>
<area href="classrepast_1_1_base_grid.html" alt="repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, GPType &gt;, GPTransformer, Adder, GPType &gt;" shape="rect" coords="0,168,533,192"/>
<area href="classrepast_1_1_base_grid.html" title="Base grid implementation, implementing elements common to both Grids and ContinuousSpaces. " alt="repast::BaseGrid&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;" shape="rect" coords="543,168,1076,192"/>
<area href="classrepast_1_1_shared_base_grid.html" title="Grid / Space implementation specialized for the distributed context. " alt="repast::SharedBaseGrid&lt; T, GPTransformer, Adder, GPType &gt;" shape="rect" coords="0,224,533,248"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0ee11fc5977ad4951f199cb90338c45f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_grid.html#a0ee11fc5977ad4951f199cb90338c45f">Grid</a> (std::string <a class="el" href="classrepast_1_1_projection.html#ab60a0ab4f584685780307d7431b61800">name</a>)</td></tr>
<tr class="memdesc:a0ee11fc5977ad4951f199cb90338c45f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classrepast_1_1_grid.html" title="Abstract interface for Grids and ContinuousSpaces. ">Grid</a> with the specified name.  <a href="#a0ee11fc5977ad4951f199cb90338c45f">More...</a><br /></td></tr>
<tr class="separator:a0ee11fc5977ad4951f199cb90338c45f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022599f875eeb1e72c11766500d8282c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_grid.html#a022599f875eeb1e72c11766500d8282c">contains</a> (const <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &amp;id)=0</td></tr>
<tr class="memdesc:a022599f875eeb1e72c11766500d8282c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether or not this grid contains the agent with the specified id.  <a href="#a022599f875eeb1e72c11766500d8282c">More...</a><br /></td></tr>
<tr class="separator:a022599f875eeb1e72c11766500d8282c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5bf061d62f1998e0c75bf3967ac63d3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_grid.html#ae5bf061d62f1998e0c75bf3967ac63d3">moveTo</a> (const <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &amp;id, const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;pt)=0</td></tr>
<tr class="memdesc:ae5bf061d62f1998e0c75bf3967ac63d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the specified agent to the specified point.  <a href="#ae5bf061d62f1998e0c75bf3967ac63d3">More...</a><br /></td></tr>
<tr class="separator:ae5bf061d62f1998e0c75bf3967ac63d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea1658b984c21ae95bd8f25ecb609b6"><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; bool, <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_grid.html#adea1658b984c21ae95bd8f25ecb609b6">moveByVector</a> (const T *agent, double distance, const std::vector&lt; double &gt; &amp;anglesInRadians)=0</td></tr>
<tr class="memdesc:adea1658b984c21ae95bd8f25ecb609b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the specifed object the specified distance from its current position along the specified angle.  <a href="#adea1658b984c21ae95bd8f25ecb609b6">More...</a><br /></td></tr>
<tr class="separator:adea1658b984c21ae95bd8f25ecb609b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20efd6bdadf8dac405542de7e33f6b9e"><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; bool, <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_grid.html#a20efd6bdadf8dac405542de7e33f6b9e">moveByDisplacement</a> (const T *agent, const std::vector&lt; GPType &gt; &amp;displacement)=0</td></tr>
<tr class="memdesc:a20efd6bdadf8dac405542de7e33f6b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the specified object from its current location by the specified amount.  <a href="#a20efd6bdadf8dac405542de7e33f6b9e">More...</a><br /></td></tr>
<tr class="separator:a20efd6bdadf8dac405542de7e33f6b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a979a6491565212ae44b8bfbbc9393"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classrepast_1_1_grid_dimensions.html">GridDimensions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_grid.html#ac6a979a6491565212ae44b8bfbbc9393">dimensions</a> () const =0</td></tr>
<tr class="memdesc:ac6a979a6491565212ae44b8bfbbc9393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the dimensions of this <a class="el" href="classrepast_1_1_grid.html" title="Abstract interface for Grids and ContinuousSpaces. ">Grid</a>.  <a href="#ac6a979a6491565212ae44b8bfbbc9393">More...</a><br /></td></tr>
<tr class="separator:ac6a979a6491565212ae44b8bfbbc9393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe975f7aa1ba40dafaefebf67b118f9e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe975f7aa1ba40dafaefebf67b118f9e"></a>
virtual const <a class="el" href="classrepast_1_1_grid_dimensions.html">GridDimensions</a>&#160;</td><td class="memItemRight" valign="bottom"><b>bounds</b> () const =0</td></tr>
<tr class="separator:afe975f7aa1ba40dafaefebf67b118f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b77b072353aed6f06b6d02e21ee9879"><td class="memItemLeft" align="right" valign="top">virtual T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_grid.html#a8b77b072353aed6f06b6d02e21ee9879">getObjectAt</a> (const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;pt) const =0</td></tr>
<tr class="memdesc:a8b77b072353aed6f06b6d02e21ee9879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the first object found at the specified point, or NULL if there is no such object.  <a href="#a8b77b072353aed6f06b6d02e21ee9879">More...</a><br /></td></tr>
<tr class="separator:a8b77b072353aed6f06b6d02e21ee9879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3a1fd92707079f7dd4805e36ca83ff"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_grid.html#aaa3a1fd92707079f7dd4805e36ca83ff">getObjectsAt</a> (const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;pt, std::vector&lt; T * &gt; &amp;out) const =0</td></tr>
<tr class="memdesc:aaa3a1fd92707079f7dd4805e36ca83ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all the objects found at the specified point.  <a href="#aaa3a1fd92707079f7dd4805e36ca83ff">More...</a><br /></td></tr>
<tr class="separator:aaa3a1fd92707079f7dd4805e36ca83ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159a33da91ef58dbd8ca88829d82ca36"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_grid.html#a159a33da91ef58dbd8ca88829d82ca36">getLocation</a> (const T *agent, std::vector&lt; GPType &gt; &amp;out) const =0</td></tr>
<tr class="memdesc:a159a33da91ef58dbd8ca88829d82ca36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the location of this agent and puts it in the specified vector.  <a href="#a159a33da91ef58dbd8ca88829d82ca36">More...</a><br /></td></tr>
<tr class="separator:a159a33da91ef58dbd8ca88829d82ca36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fef590f66b69e4a06207df59d1b2737"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_grid.html#a6fef590f66b69e4a06207df59d1b2737">getLocation</a> (const <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &amp;id, std::vector&lt; GPType &gt; &amp;out) const =0</td></tr>
<tr class="memdesc:a6fef590f66b69e4a06207df59d1b2737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the location of this agent and puts it in the specified vectors.  <a href="#a6fef590f66b69e4a06207df59d1b2737">More...</a><br /></td></tr>
<tr class="separator:a6fef590f66b69e4a06207df59d1b2737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23236c2387ba343121dbf71901dbb341"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_grid.html#a23236c2387ba343121dbf71901dbb341">getDisplacement</a> (const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;pt1, const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;pt2, std::vector&lt; GPType &gt; &amp;out) const =0</td></tr>
<tr class="memdesc:a23236c2387ba343121dbf71901dbb341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets vector difference between point 1 and point 2, putting the result in out.  <a href="#a23236c2387ba343121dbf71901dbb341">More...</a><br /></td></tr>
<tr class="separator:a23236c2387ba343121dbf71901dbb341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27213b5f9decf10e1c99a5a7b4ae387a"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_grid.html#a27213b5f9decf10e1c99a5a7b4ae387a">getDistance</a> (const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;pt1, const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;pt2) const =0</td></tr>
<tr class="memdesc:a27213b5f9decf10e1c99a5a7b4ae387a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the distance between the two grid points.  <a href="#a27213b5f9decf10e1c99a5a7b4ae387a">More...</a><br /></td></tr>
<tr class="separator:a27213b5f9decf10e1c99a5a7b4ae387a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456d00d28995a48b41b8f6c84817879e"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_grid.html#a456d00d28995a48b41b8f6c84817879e">getDistanceSq</a> (const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;pt1, const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;pt2) const =0</td></tr>
<tr class="memdesc:a456d00d28995a48b41b8f6c84817879e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the square of the distance between the two grid points.  <a href="#a456d00d28995a48b41b8f6c84817879e">More...</a><br /></td></tr>
<tr class="separator:a456d00d28995a48b41b8f6c84817879e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa30c315b9a32830b804d2e49af14d0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_grid.html#a5aa30c315b9a32830b804d2e49af14d0">translate</a> (const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;location, const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;displacement, std::vector&lt; GPType &gt; &amp;out) const =0</td></tr>
<tr class="memdesc:a5aa30c315b9a32830b804d2e49af14d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates the specified location by the specified displacement put the result in out.  <a href="#a5aa30c315b9a32830b804d2e49af14d0">More...</a><br /></td></tr>
<tr class="separator:a5aa30c315b9a32830b804d2e49af14d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001bf75cd2e436112555a5f992d1d372"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_grid.html#a001bf75cd2e436112555a5f992d1d372">transform</a> (const std::vector&lt; GPType &gt; &amp;location, std::vector&lt; GPType &gt; &amp;out) const =0</td></tr>
<tr class="memdesc:a001bf75cd2e436112555a5f992d1d372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the specified location using the properties (e.g.  <a href="#a001bf75cd2e436112555a5f992d1d372">More...</a><br /></td></tr>
<tr class="separator:a001bf75cd2e436112555a5f992d1d372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e7eb612dabbf2fb4b3f1190cd92f88"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_grid.html#a81e7eb612dabbf2fb4b3f1190cd92f88">isPeriodic</a> () const =0</td></tr>
<tr class="memdesc:a81e7eb612dabbf2fb4b3f1190cd92f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether or not this grid is periodic (i.e.  <a href="#a81e7eb612dabbf2fb4b3f1190cd92f88">More...</a><br /></td></tr>
<tr class="separator:a81e7eb612dabbf2fb4b3f1190cd92f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768c6b3b623a0b06e96321738af2da41"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a768c6b3b623a0b06e96321738af2da41"></a>
virtual <a class="el" href="classrepast_1_1_projection_info_packet.html">ProjectionInfoPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getProjectionInfo</b> (<a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> id, bool secondaryInfo=false, std::set&lt; <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &gt; *secondaryIds=0, int destProc=-1)=0</td></tr>
<tr class="separator:a768c6b3b623a0b06e96321738af2da41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f9208e8224c3a63a41c935906ffe6b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69f9208e8224c3a63a41c935906ffe6b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>updateProjectionInfo</b> (<a class="el" href="classrepast_1_1_projection_info_packet.html">ProjectionInfoPacket</a> *pip, <a class="el" href="classrepast_1_1_context.html">Context</a>&lt; T &gt; *context)=0</td></tr>
<tr class="separator:a69f9208e8224c3a63a41c935906ffe6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ff08ad641de4f74eab53e30ad14eb6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_grid.html#ab1ff08ad641de4f74eab53e30ad14eb6">getRequiredAgents</a> (std::set&lt; <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &gt; &amp;agentsToTest, std::set&lt; <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &gt; &amp;agentsRequired, RADIUS radius=<a class="el" href="classrepast_1_1_projection.html">Projection</a>&lt; T &gt;::PRIMARY)</td></tr>
<tr class="memdesc:ab1ff08ad641de4f74eab53e30ad14eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of agents to test, gets the subset that must be kept in order to fulfill the projection's 'contract' to the specified radius.  <a href="#ab1ff08ad641de4f74eab53e30ad14eb6">More...</a><br /></td></tr>
<tr class="separator:ab1ff08ad641de4f74eab53e30ad14eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa83b294fc8765e2f8ee44d8238855460"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_grid.html#aa83b294fc8765e2f8ee44d8238855460">getAgentsToPush</a> (std::set&lt; <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &gt; &amp;agentsToTest, std::map&lt; int, std::set&lt; <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &gt; &gt; &amp;agentsToPush)=0</td></tr>
<tr class="memdesc:aa83b294fc8765e2f8ee44d8238855460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of agents, gets the agents that this projection implementation must 'push' to other processes.  <a href="#aa83b294fc8765e2f8ee44d8238855460">More...</a><br /></td></tr>
<tr class="separator:aa83b294fc8765e2f8ee44d8238855460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46a5e7692430604bb3b04bbb9e2ff50"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_grid.html#aa46a5e7692430604bb3b04bbb9e2ff50">keepsAgentsOnSyncProj</a> ()</td></tr>
<tr class="memdesc:aa46a5e7692430604bb3b04bbb9e2ff50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should return true if the <a class="el" href="classrepast_1_1_projection.html" title="Abstract base class for all Projections. ">Projection</a> implemented can 'keep' some (non-local) agents during a projection information synchronization operation.  <a href="#aa46a5e7692430604bb3b04bbb9e2ff50">More...</a><br /></td></tr>
<tr class="separator:aa46a5e7692430604bb3b04bbb9e2ff50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b7e2de573a9212a58a527a9ab519b8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_grid.html#ae3b7e2de573a9212a58a527a9ab519b8">sendsSecondaryAgentsOnStatusExchange</a> ()</td></tr>
<tr class="memdesc:ae3b7e2de573a9212a58a527a9ab519b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should return true if the <a class="el" href="classrepast_1_1_projection.html" title="Abstract base class for all Projections. ">Projection</a> implemented will send secondary agents during a status exchange.  <a href="#ae3b7e2de573a9212a58a527a9ab519b8">More...</a><br /></td></tr>
<tr class="separator:ae3b7e2de573a9212a58a527a9ab519b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b4449e602392119eb4db3e0011de05"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_grid.html#a57b4449e602392119eb4db3e0011de05">getInfoExchangePartners</a> (std::set&lt; int &gt; &amp;psToSendTo, std::set&lt; int &gt; &amp;psToReceiveFrom)=0</td></tr>
<tr class="memdesc:a57b4449e602392119eb4db3e0011de05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the set of processes with which this <a class="el" href="classrepast_1_1_projection.html" title="Abstract base class for all Projections. ">Projection</a> exchanges projection info.  <a href="#a57b4449e602392119eb4db3e0011de05">More...</a><br /></td></tr>
<tr class="separator:a57b4449e602392119eb4db3e0011de05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748354698308fe0d0c0fe33a657109d1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_grid.html#a748354698308fe0d0c0fe33a657109d1">getAgentStatusExchangePartners</a> (std::set&lt; int &gt; &amp;psToSendTo, std::set&lt; int &gt; &amp;psToReceiveFrom)=0</td></tr>
<tr class="memdesc:a748354698308fe0d0c0fe33a657109d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the set of processes with which this <a class="el" href="classrepast_1_1_projection.html" title="Abstract base class for all Projections. ">Projection</a> exchanges agent status info- that is, the set of processes from which agents can move to this one or to which they can move when moving from this one.  <a href="#a748354698308fe0d0c0fe33a657109d1">More...</a><br /></td></tr>
<tr class="separator:a748354698308fe0d0c0fe33a657109d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b6d41862836606e0393df7558e4d20"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4b6d41862836606e0393df7558e4d20"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>cleanProjectionInfo</b> (std::set&lt; <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &gt; &amp;agentsToKeep)</td></tr>
<tr class="separator:ae4b6d41862836606e0393df7558e4d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classrepast_1_1_projection"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classrepast_1_1_projection')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classrepast_1_1_projection.html">repast::Projection&lt; T &gt;</a></td></tr>
<tr class="memitem:a2c5c9f33cf57c5e7a00402eab2080051 inherit pub_methods_classrepast_1_1_projection"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_projection.html#a2c5c9f33cf57c5e7a00402eab2080051">Projection</a> (std::string <a class="el" href="classrepast_1_1_projection.html#ab60a0ab4f584685780307d7431b61800">name</a>)</td></tr>
<tr class="memdesc:a2c5c9f33cf57c5e7a00402eab2080051 inherit pub_methods_classrepast_1_1_projection"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a projection with specified name.  <a href="#a2c5c9f33cf57c5e7a00402eab2080051">More...</a><br /></td></tr>
<tr class="separator:a2c5c9f33cf57c5e7a00402eab2080051 inherit pub_methods_classrepast_1_1_projection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab60a0ab4f584685780307d7431b61800 inherit pub_methods_classrepast_1_1_projection"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab60a0ab4f584685780307d7431b61800"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_projection.html#ab60a0ab4f584685780307d7431b61800">name</a> () const </td></tr>
<tr class="memdesc:ab60a0ab4f584685780307d7431b61800 inherit pub_methods_classrepast_1_1_projection"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name of this projection. <br /></td></tr>
<tr class="separator:ab60a0ab4f584685780307d7431b61800 inherit pub_methods_classrepast_1_1_projection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340bcbf86f1e29489b9ca1a4aa5e9298 inherit pub_methods_classrepast_1_1_projection"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_projection.html#a340bcbf86f1e29489b9ca1a4aa5e9298">addFilterVal</a> (int type)</td></tr>
<tr class="memdesc:a340bcbf86f1e29489b9ca1a4aa5e9298 inherit pub_methods_classrepast_1_1_projection"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an entry to the list of agent types that can be added to this projection.  <a href="#a340bcbf86f1e29489b9ca1a4aa5e9298">More...</a><br /></td></tr>
<tr class="separator:a340bcbf86f1e29489b9ca1a4aa5e9298 inherit pub_methods_classrepast_1_1_projection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4587f793b1c250de22af16fedf7f89d inherit pub_methods_classrepast_1_1_projection"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_projection.html#ab4587f793b1c250de22af16fedf7f89d">removeFilterVal</a> (int type)</td></tr>
<tr class="memdesc:ab4587f793b1c250de22af16fedf7f89d inherit pub_methods_classrepast_1_1_projection"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an entry from the list of agent types that can be added to this projection.  <a href="#ab4587f793b1c250de22af16fedf7f89d">More...</a><br /></td></tr>
<tr class="separator:ab4587f793b1c250de22af16fedf7f89d inherit pub_methods_classrepast_1_1_projection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35eae2c3351ef0de242a2ebeac8719df inherit pub_methods_classrepast_1_1_projection"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35eae2c3351ef0de242a2ebeac8719df"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_projection.html#a35eae2c3351ef0de242a2ebeac8719df">clearFilter</a> ()</td></tr>
<tr class="memdesc:a35eae2c3351ef0de242a2ebeac8719df inherit pub_methods_classrepast_1_1_projection"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the list of agent types that can be added to this projection; the result is that the filter is empty, and any agent can be added. <br /></td></tr>
<tr class="separator:a35eae2c3351ef0de242a2ebeac8719df inherit pub_methods_classrepast_1_1_projection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4075a777a46f27e978d376c90e74a409 inherit pub_methods_classrepast_1_1_projection"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_projection.html#a4075a777a46f27e978d376c90e74a409">agentCanBeAdded</a> (boost::shared_ptr&lt; T &gt; agent)</td></tr>
<tr class="memdesc:a4075a777a46f27e978d376c90e74a409 inherit pub_methods_classrepast_1_1_projection"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the agent can be added to the projection, which will be the case if the filter list is empty or if the agent's type is in the filter list.  <a href="#a4075a777a46f27e978d376c90e74a409">More...</a><br /></td></tr>
<tr class="separator:a4075a777a46f27e978d376c90e74a409 inherit pub_methods_classrepast_1_1_projection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66e268656f0baee2a7656d5eda6f4b9 inherit pub_methods_classrepast_1_1_projection"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae66e268656f0baee2a7656d5eda6f4b9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_projection.html#ae66e268656f0baee2a7656d5eda6f4b9">getProjectionInfo</a> (std::vector&lt; <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &gt; &amp;agents, std::vector&lt; <a class="el" href="classrepast_1_1_projection_info_packet.html">ProjectionInfoPacket</a> * &gt; &amp;packets, bool secondaryInfo=false, std::set&lt; <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &gt; *secondaryIds=0, int destProc=-1)</td></tr>
<tr class="memdesc:ae66e268656f0baee2a7656d5eda6f4b9 inherit pub_methods_classrepast_1_1_projection"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper that gets all of the projection information for the agents specified (calls implementation in child class that gets only the information for one agent). <br /></td></tr>
<tr class="separator:ae66e268656f0baee2a7656d5eda6f4b9 inherit pub_methods_classrepast_1_1_projection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89c14a3463d292ba1cd829204fbee71 inherit pub_methods_classrepast_1_1_projection"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae89c14a3463d292ba1cd829204fbee71"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_projection.html#ae89c14a3463d292ba1cd829204fbee71">updateProjectionInfo</a> (std::vector&lt; <a class="el" href="classrepast_1_1_projection_info_packet.html">ProjectionInfoPacket</a> * &gt; &amp;pips, <a class="el" href="classrepast_1_1_context.html">Context</a>&lt; T &gt; *context)</td></tr>
<tr class="memdesc:ae89c14a3463d292ba1cd829204fbee71 inherit pub_methods_classrepast_1_1_projection"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the projection information for the agents in this projection according to the information contained in the vector of information packets passed. <br /></td></tr>
<tr class="separator:ae89c14a3463d292ba1cd829204fbee71 inherit pub_methods_classrepast_1_1_projection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5cda203753da3d565d7839f92589e8 inherit pub_methods_classrepast_1_1_projection"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd5cda203753da3d565d7839f92589e8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>balance</b> ()</td></tr>
<tr class="separator:afd5cda203753da3d565d7839f92589e8 inherit pub_methods_classrepast_1_1_projection"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classrepast_1_1_projection"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classrepast_1_1_projection')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classrepast_1_1_projection.html">repast::Projection&lt; T &gt;</a></td></tr>
<tr class="memitem:ad4e03ba91fa58d03596836c6d76d5c80 inherit pub_types_classrepast_1_1_projection"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4e03ba91fa58d03596836c6d76d5c80"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>RADIUS</b> { <b>PRIMARY</b>, 
<b>SECONDARY</b>
 }</td></tr>
<tr class="separator:ad4e03ba91fa58d03596836c6d76d5c80 inherit pub_types_classrepast_1_1_projection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classrepast_1_1_projection"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classrepast_1_1_projection')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classrepast_1_1_projection.html">repast::Projection&lt; T &gt;</a></td></tr>
<tr class="memitem:ac232dfc16ee5ccdb04d694abf79ce9a3 inherit pro_methods_classrepast_1_1_projection"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac232dfc16ee5ccdb04d694abf79ce9a3"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>addAgent</b> (boost::shared_ptr&lt; T &gt; agent)=0</td></tr>
<tr class="separator:ac232dfc16ee5ccdb04d694abf79ce9a3 inherit pro_methods_classrepast_1_1_projection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804afdbcd384a23f7bf2c7a53209f272 inherit pro_methods_classrepast_1_1_projection"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a804afdbcd384a23f7bf2c7a53209f272"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>removeAgent</b> (T *agent)=0</td></tr>
<tr class="separator:a804afdbcd384a23f7bf2c7a53209f272 inherit pro_methods_classrepast_1_1_projection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classrepast_1_1_projection"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classrepast_1_1_projection')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classrepast_1_1_projection.html">repast::Projection&lt; T &gt;</a></td></tr>
<tr class="memitem:a374d61a05feb62c25e2046170fbd2be4 inherit pro_attribs_classrepast_1_1_projection"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a374d61a05feb62c25e2046170fbd2be4"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>name_</b></td></tr>
<tr class="separator:a374d61a05feb62c25e2046170fbd2be4 inherit pro_attribs_classrepast_1_1_projection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2db74e98e56396c2a129a7aefeb19e inherit pro_attribs_classrepast_1_1_projection"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade2db74e98e56396c2a129a7aefeb19e"></a>
std::set&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>filter</b></td></tr>
<tr class="separator:ade2db74e98e56396c2a129a7aefeb19e inherit pro_attribs_classrepast_1_1_projection"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename GPType&gt;<br />
class repast::Grid&lt; T, GPType &gt;</h3>

<p>Abstract interface for Grids and ContinuousSpaces. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of objects this <a class="el" href="classrepast_1_1_grid.html" title="Abstract interface for Grids and ContinuousSpaces. ">Grid</a> contains </td></tr>
    <tr><td class="paramname">GPType</td><td>the coordinate type of the grid point locations. This must be an int or a double. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0ee11fc5977ad4951f199cb90338c45f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrepast_1_1_grid.html">repast::Grid</a>&lt; T, GPType &gt;::<a class="el" href="classrepast_1_1_grid.html">Grid</a> </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classrepast_1_1_grid.html" title="Abstract interface for Grids and ContinuousSpaces. ">Grid</a> with the specified name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the <a class="el" href="classrepast_1_1_grid.html" title="Abstract interface for Grids and ContinuousSpaces. ">Grid</a>. This should be unique among Projections. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a022599f875eeb1e72c11766500d8282c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classrepast_1_1_grid.html">repast::Grid</a>&lt; T, GPType &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether or not this grid contains the agent with the specified id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the id of the agent to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the grid contains the agent, otherwise false. </dd></dl>

<p>Implemented in <a class="el" href="classrepast_1_1_base_grid.html#a648fcba07fdc15b4072b5807b4f1b6b0">repast::BaseGrid&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a648fcba07fdc15b4072b5807b4f1b6b0">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, double &gt;, GPTransformer, Adder, double &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a648fcba07fdc15b4072b5807b4f1b6b0">repast::BaseGrid&lt; RelogoAgent, MultipleOccupancy&lt; RelogoAgent, double &gt;, GPTransformer, Adder, double &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a648fcba07fdc15b4072b5807b4f1b6b0">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, GPType &gt;, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a648fcba07fdc15b4072b5807b4f1b6b0">repast::BaseGrid&lt; RelogoAgent, MultipleOccupancy&lt; RelogoAgent, int &gt;, GPTransformer, Adder, int &gt;</a>, and <a class="el" href="classrepast_1_1_base_grid.html#a648fcba07fdc15b4072b5807b4f1b6b0">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, int &gt;, GPTransformer, Adder, int &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ac6a979a6491565212ae44b8bfbbc9393"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classrepast_1_1_grid_dimensions.html">GridDimensions</a> <a class="el" href="classrepast_1_1_grid.html">repast::Grid</a>&lt; T, GPType &gt;::dimensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the dimensions of this <a class="el" href="classrepast_1_1_grid.html" title="Abstract interface for Grids and ContinuousSpaces. ">Grid</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the dimensions of this <a class="el" href="classrepast_1_1_grid.html" title="Abstract interface for Grids and ContinuousSpaces. ">Grid</a>. </dd></dl>

<p>Implemented in <a class="el" href="classrepast_1_1_base_grid.html#a5f8a2fc16b8aeba026a58fcb374cf05c">repast::BaseGrid&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a5f8a2fc16b8aeba026a58fcb374cf05c">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, double &gt;, GPTransformer, Adder, double &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a5f8a2fc16b8aeba026a58fcb374cf05c">repast::BaseGrid&lt; RelogoAgent, MultipleOccupancy&lt; RelogoAgent, double &gt;, GPTransformer, Adder, double &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a5f8a2fc16b8aeba026a58fcb374cf05c">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, GPType &gt;, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a5f8a2fc16b8aeba026a58fcb374cf05c">repast::BaseGrid&lt; RelogoAgent, MultipleOccupancy&lt; RelogoAgent, int &gt;, GPTransformer, Adder, int &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a5f8a2fc16b8aeba026a58fcb374cf05c">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, int &gt;, GPTransformer, Adder, int &gt;</a>, <a class="el" href="classrepast_1_1_shared_base_grid.html#a9ec19652232000368ec1fe98ff47e121">repast::SharedBaseGrid&lt; T, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_shared_base_grid.html#a9ec19652232000368ec1fe98ff47e121">repast::SharedBaseGrid&lt; RelogoAgent, GPTransformer, Adder, int &gt;</a>, <a class="el" href="classrepast_1_1_shared_base_grid.html#a9ec19652232000368ec1fe98ff47e121">repast::SharedBaseGrid&lt; T, GPTransformer, Adder, int &gt;</a>, <a class="el" href="classrepast_1_1_shared_base_grid.html#a9ec19652232000368ec1fe98ff47e121">repast::SharedBaseGrid&lt; T, GPTransformer, Adder, double &gt;</a>, and <a class="el" href="classrepast_1_1_shared_base_grid.html#a9ec19652232000368ec1fe98ff47e121">repast::SharedBaseGrid&lt; RelogoAgent, GPTransformer, Adder, double &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a748354698308fe0d0c0fe33a657109d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classrepast_1_1_grid.html">repast::Grid</a>&lt; T, GPType &gt;::getAgentStatusExchangePartners </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>psToSendTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>psToReceiveFrom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the set of processes with which this <a class="el" href="classrepast_1_1_projection.html" title="Abstract base class for all Projections. ">Projection</a> exchanges agent status info- that is, the set of processes from which agents can move to this one or to which they can move when moving from this one. </p>
<p>In the most general case this will be all other processors. However, simulations where agents move in spaces will usually exchange agents only with a small subset of 'neighbor' processes, which is knowable in advance and constant. To accommodate the general case, the algorithm for exchanging information must poll all other processes to see which are sending to this one; if this is known in advance, this additional (expensive) step can be skipped. </p>

<p>Implements <a class="el" href="classrepast_1_1_projection.html#ad2d104bb6119d0911053d450932855d5">repast::Projection&lt; T &gt;</a>.</p>

<p>Implemented in <a class="el" href="classrepast_1_1_base_grid.html#ab77e5a4fba771e92b141f03f566b2a11">repast::BaseGrid&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#ab77e5a4fba771e92b141f03f566b2a11">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, double &gt;, GPTransformer, Adder, double &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#ab77e5a4fba771e92b141f03f566b2a11">repast::BaseGrid&lt; RelogoAgent, MultipleOccupancy&lt; RelogoAgent, double &gt;, GPTransformer, Adder, double &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#ab77e5a4fba771e92b141f03f566b2a11">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, GPType &gt;, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#ab77e5a4fba771e92b141f03f566b2a11">repast::BaseGrid&lt; RelogoAgent, MultipleOccupancy&lt; RelogoAgent, int &gt;, GPTransformer, Adder, int &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#ab77e5a4fba771e92b141f03f566b2a11">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, int &gt;, GPTransformer, Adder, int &gt;</a>, <a class="el" href="classrepast_1_1_shared_base_grid.html#a0388d98240eb59548058d3c45da702d7">repast::SharedBaseGrid&lt; T, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_shared_base_grid.html#a0388d98240eb59548058d3c45da702d7">repast::SharedBaseGrid&lt; RelogoAgent, GPTransformer, Adder, int &gt;</a>, <a class="el" href="classrepast_1_1_shared_base_grid.html#a0388d98240eb59548058d3c45da702d7">repast::SharedBaseGrid&lt; T, GPTransformer, Adder, int &gt;</a>, <a class="el" href="classrepast_1_1_shared_base_grid.html#a0388d98240eb59548058d3c45da702d7">repast::SharedBaseGrid&lt; T, GPTransformer, Adder, double &gt;</a>, and <a class="el" href="classrepast_1_1_shared_base_grid.html#a0388d98240eb59548058d3c45da702d7">repast::SharedBaseGrid&lt; RelogoAgent, GPTransformer, Adder, double &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aa83b294fc8765e2f8ee44d8238855460"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classrepast_1_1_grid.html">repast::Grid</a>&lt; T, GPType &gt;::getAgentsToPush </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>agentsToTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; int, std::set&lt; <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>agentsToPush</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a set of agents, gets the agents that this projection implementation must 'push' to other processes. </p>
<p>Generally spaces must push agents that are in 'buffer zones' and graphs must push local agents that are vertices to master edges where the other vertex is non- local. The results are returned per-process in the agentsToPush map. </p>

<p>Implements <a class="el" href="classrepast_1_1_projection.html#ae1877809facd80a5e25d95e3dc5c35f4">repast::Projection&lt; T &gt;</a>.</p>

<p>Implemented in <a class="el" href="classrepast_1_1_base_grid.html#a8f718ade5af8285f71151eea824ce3cd">repast::BaseGrid&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a8f718ade5af8285f71151eea824ce3cd">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, double &gt;, GPTransformer, Adder, double &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a8f718ade5af8285f71151eea824ce3cd">repast::BaseGrid&lt; RelogoAgent, MultipleOccupancy&lt; RelogoAgent, double &gt;, GPTransformer, Adder, double &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a8f718ade5af8285f71151eea824ce3cd">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, GPType &gt;, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a8f718ade5af8285f71151eea824ce3cd">repast::BaseGrid&lt; RelogoAgent, MultipleOccupancy&lt; RelogoAgent, int &gt;, GPTransformer, Adder, int &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a8f718ade5af8285f71151eea824ce3cd">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, int &gt;, GPTransformer, Adder, int &gt;</a>, <a class="el" href="classrepast_1_1_shared_base_grid.html#ab1486e7698288efc1218653d4e5e1e15">repast::SharedBaseGrid&lt; T, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_shared_base_grid.html#ab1486e7698288efc1218653d4e5e1e15">repast::SharedBaseGrid&lt; RelogoAgent, GPTransformer, Adder, int &gt;</a>, <a class="el" href="classrepast_1_1_shared_base_grid.html#ab1486e7698288efc1218653d4e5e1e15">repast::SharedBaseGrid&lt; T, GPTransformer, Adder, int &gt;</a>, <a class="el" href="classrepast_1_1_shared_base_grid.html#ab1486e7698288efc1218653d4e5e1e15">repast::SharedBaseGrid&lt; T, GPTransformer, Adder, double &gt;</a>, and <a class="el" href="classrepast_1_1_shared_base_grid.html#ab1486e7698288efc1218653d4e5e1e15">repast::SharedBaseGrid&lt; RelogoAgent, GPTransformer, Adder, double &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a23236c2387ba343121dbf71901dbb341"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classrepast_1_1_grid.html">repast::Grid</a>&lt; T, GPType &gt;::getDisplacement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; GPType &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets vector difference between point 1 and point 2, putting the result in out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">p1</td><td>the first point </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">p2</td><td>the second point </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">the</td><td>vector where the difference will be put </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classrepast_1_1_base_grid.html#a8c3b8755d2fc2bf75163a0fc76ce1d4a">repast::BaseGrid&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a8c3b8755d2fc2bf75163a0fc76ce1d4a">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, double &gt;, GPTransformer, Adder, double &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a8c3b8755d2fc2bf75163a0fc76ce1d4a">repast::BaseGrid&lt; RelogoAgent, MultipleOccupancy&lt; RelogoAgent, double &gt;, GPTransformer, Adder, double &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a8c3b8755d2fc2bf75163a0fc76ce1d4a">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, GPType &gt;, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a8c3b8755d2fc2bf75163a0fc76ce1d4a">repast::BaseGrid&lt; RelogoAgent, MultipleOccupancy&lt; RelogoAgent, int &gt;, GPTransformer, Adder, int &gt;</a>, and <a class="el" href="classrepast_1_1_base_grid.html#a8c3b8755d2fc2bf75163a0fc76ce1d4a">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, int &gt;, GPTransformer, Adder, int &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a27213b5f9decf10e1c99a5a7b4ae387a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double <a class="el" href="classrepast_1_1_grid.html">repast::Grid</a>&lt; T, GPType &gt;::getDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the distance between the two grid points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>the first point </td></tr>
    <tr><td class="paramname">p2</td><td>the second point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the distance between pt1 and pt2. </dd></dl>

<p>Implemented in <a class="el" href="classrepast_1_1_base_grid.html#a124b5f53a5e96e9ed8e59534e9417f42">repast::BaseGrid&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a124b5f53a5e96e9ed8e59534e9417f42">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, double &gt;, GPTransformer, Adder, double &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a124b5f53a5e96e9ed8e59534e9417f42">repast::BaseGrid&lt; RelogoAgent, MultipleOccupancy&lt; RelogoAgent, double &gt;, GPTransformer, Adder, double &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a124b5f53a5e96e9ed8e59534e9417f42">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, GPType &gt;, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a124b5f53a5e96e9ed8e59534e9417f42">repast::BaseGrid&lt; RelogoAgent, MultipleOccupancy&lt; RelogoAgent, int &gt;, GPTransformer, Adder, int &gt;</a>, and <a class="el" href="classrepast_1_1_base_grid.html#a124b5f53a5e96e9ed8e59534e9417f42">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, int &gt;, GPTransformer, Adder, int &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a456d00d28995a48b41b8f6c84817879e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double <a class="el" href="classrepast_1_1_grid.html">repast::Grid</a>&lt; T, GPType &gt;::getDistanceSq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the square of the distance between the two grid points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>the first point </td></tr>
    <tr><td class="paramname">p2</td><td>the second point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the square of the distance between pt1 and pt2. </dd></dl>

<p>Implemented in <a class="el" href="classrepast_1_1_base_grid.html#a8075dd20e6d559d453a530943ab9d387">repast::BaseGrid&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a8075dd20e6d559d453a530943ab9d387">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, double &gt;, GPTransformer, Adder, double &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a8075dd20e6d559d453a530943ab9d387">repast::BaseGrid&lt; RelogoAgent, MultipleOccupancy&lt; RelogoAgent, double &gt;, GPTransformer, Adder, double &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a8075dd20e6d559d453a530943ab9d387">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, GPType &gt;, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a8075dd20e6d559d453a530943ab9d387">repast::BaseGrid&lt; RelogoAgent, MultipleOccupancy&lt; RelogoAgent, int &gt;, GPTransformer, Adder, int &gt;</a>, and <a class="el" href="classrepast_1_1_base_grid.html#a8075dd20e6d559d453a530943ab9d387">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, int &gt;, GPTransformer, Adder, int &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a57b4449e602392119eb4db3e0011de05"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classrepast_1_1_grid.html">repast::Grid</a>&lt; T, GPType &gt;::getInfoExchangePartners </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>psToSendTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>psToReceiveFrom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the set of processes with which this <a class="el" href="classrepast_1_1_projection.html" title="Abstract base class for all Projections. ">Projection</a> exchanges projection info. </p>
<p>In the most general case this will be all other processors; this is the case for graphs, where agent connections can be arbitrary. However, spaces usually exchange information only with a small subset of 'neighbor' processes, which is knowable in advance and constant. To accommodate the general case, the algorithm for exchanging information must poll all other processes to see which are sending to this one; if this is known in advance, this additional (expensive) step can be skipped. </p>

<p>Implements <a class="el" href="classrepast_1_1_projection.html#afdc13fccb129094bfd67b3446873933d">repast::Projection&lt; T &gt;</a>.</p>

<p>Implemented in <a class="el" href="classrepast_1_1_base_grid.html#a9bbbd16324d70e859dea27feebed3f58">repast::BaseGrid&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a9bbbd16324d70e859dea27feebed3f58">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, double &gt;, GPTransformer, Adder, double &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a9bbbd16324d70e859dea27feebed3f58">repast::BaseGrid&lt; RelogoAgent, MultipleOccupancy&lt; RelogoAgent, double &gt;, GPTransformer, Adder, double &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a9bbbd16324d70e859dea27feebed3f58">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, GPType &gt;, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a9bbbd16324d70e859dea27feebed3f58">repast::BaseGrid&lt; RelogoAgent, MultipleOccupancy&lt; RelogoAgent, int &gt;, GPTransformer, Adder, int &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a9bbbd16324d70e859dea27feebed3f58">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, int &gt;, GPTransformer, Adder, int &gt;</a>, <a class="el" href="classrepast_1_1_shared_base_grid.html#af4323686714c4f6216125db5609c3184">repast::SharedBaseGrid&lt; T, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_shared_base_grid.html#af4323686714c4f6216125db5609c3184">repast::SharedBaseGrid&lt; RelogoAgent, GPTransformer, Adder, int &gt;</a>, <a class="el" href="classrepast_1_1_shared_base_grid.html#af4323686714c4f6216125db5609c3184">repast::SharedBaseGrid&lt; T, GPTransformer, Adder, int &gt;</a>, <a class="el" href="classrepast_1_1_shared_base_grid.html#af4323686714c4f6216125db5609c3184">repast::SharedBaseGrid&lt; T, GPTransformer, Adder, double &gt;</a>, and <a class="el" href="classrepast_1_1_shared_base_grid.html#af4323686714c4f6216125db5609c3184">repast::SharedBaseGrid&lt; RelogoAgent, GPTransformer, Adder, double &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a159a33da91ef58dbd8ca88829d82ca36"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classrepast_1_1_grid.html">repast::Grid</a>&lt; T, GPType &gt;::getLocation </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>agent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; GPType &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the location of this agent and puts it in the specified vector. </p>
<p>The x coordinate will be the first value, the y the second and so on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">agent</td><td>the agent whose location we want to get </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">the</td><td>vector where the agents location will be put</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the location was successfully found, otherwise false. </dd></dl>

<p>Implemented in <a class="el" href="classrepast_1_1_base_grid.html#a9ef8aae56bb771fa152b10408d718f6e">repast::BaseGrid&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a9ef8aae56bb771fa152b10408d718f6e">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, double &gt;, GPTransformer, Adder, double &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a9ef8aae56bb771fa152b10408d718f6e">repast::BaseGrid&lt; RelogoAgent, MultipleOccupancy&lt; RelogoAgent, double &gt;, GPTransformer, Adder, double &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a9ef8aae56bb771fa152b10408d718f6e">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, GPType &gt;, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a9ef8aae56bb771fa152b10408d718f6e">repast::BaseGrid&lt; RelogoAgent, MultipleOccupancy&lt; RelogoAgent, int &gt;, GPTransformer, Adder, int &gt;</a>, and <a class="el" href="classrepast_1_1_base_grid.html#a9ef8aae56bb771fa152b10408d718f6e">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, int &gt;, GPTransformer, Adder, int &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a6fef590f66b69e4a06207df59d1b2737"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classrepast_1_1_grid.html">repast::Grid</a>&lt; T, GPType &gt;::getLocation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; GPType &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the location of this agent and puts it in the specified vectors. </p>
<p>The x coordinate will be the first value, the y the second and so on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">id</td><td>the id of the agent whose location we want to get </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>the agent's location will be put into this vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the location was successfully found, otherwise false. </dd></dl>

<p>Implemented in <a class="el" href="classrepast_1_1_base_grid.html#aa18b424b73ff46fde970ad1e1bb3cdc4">repast::BaseGrid&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#aa18b424b73ff46fde970ad1e1bb3cdc4">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, double &gt;, GPTransformer, Adder, double &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#aa18b424b73ff46fde970ad1e1bb3cdc4">repast::BaseGrid&lt; RelogoAgent, MultipleOccupancy&lt; RelogoAgent, double &gt;, GPTransformer, Adder, double &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#aa18b424b73ff46fde970ad1e1bb3cdc4">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, GPType &gt;, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#aa18b424b73ff46fde970ad1e1bb3cdc4">repast::BaseGrid&lt; RelogoAgent, MultipleOccupancy&lt; RelogoAgent, int &gt;, GPTransformer, Adder, int &gt;</a>, and <a class="el" href="classrepast_1_1_base_grid.html#aa18b424b73ff46fde970ad1e1bb3cdc4">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, int &gt;, GPTransformer, Adder, int &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a8b77b072353aed6f06b6d02e21ee9879"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual T* <a class="el" href="classrepast_1_1_grid.html">repast::Grid</a>&lt; T, GPType &gt;::getObjectAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the first object found at the specified point, or NULL if there is no such object. </p>
<dl class="section return"><dt>Returns</dt><dd>the first object found at the specified point, or NULL if there is no such object. </dd></dl>

<p>Implemented in <a class="el" href="classrepast_1_1_base_grid.html#a3710f4aca96eeb3a95a44fe80e0c998a">repast::BaseGrid&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a3710f4aca96eeb3a95a44fe80e0c998a">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, double &gt;, GPTransformer, Adder, double &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a3710f4aca96eeb3a95a44fe80e0c998a">repast::BaseGrid&lt; RelogoAgent, MultipleOccupancy&lt; RelogoAgent, double &gt;, GPTransformer, Adder, double &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a3710f4aca96eeb3a95a44fe80e0c998a">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, GPType &gt;, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a3710f4aca96eeb3a95a44fe80e0c998a">repast::BaseGrid&lt; RelogoAgent, MultipleOccupancy&lt; RelogoAgent, int &gt;, GPTransformer, Adder, int &gt;</a>, and <a class="el" href="classrepast_1_1_base_grid.html#a3710f4aca96eeb3a95a44fe80e0c998a">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, int &gt;, GPTransformer, Adder, int &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aaa3a1fd92707079f7dd4805e36ca83ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classrepast_1_1_grid.html">repast::Grid</a>&lt; T, GPType &gt;::getObjectsAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets all the objects found at the specified point. </p>
<p>The found objects will be put into the out parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pt</td><td>the point to get all the objects at </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>the vector into which the found objects will be put </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classrepast_1_1_base_grid.html#a21d840f3eb758b8f223ca51bf1996328">repast::BaseGrid&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a21d840f3eb758b8f223ca51bf1996328">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, double &gt;, GPTransformer, Adder, double &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a21d840f3eb758b8f223ca51bf1996328">repast::BaseGrid&lt; RelogoAgent, MultipleOccupancy&lt; RelogoAgent, double &gt;, GPTransformer, Adder, double &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a21d840f3eb758b8f223ca51bf1996328">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, GPType &gt;, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a21d840f3eb758b8f223ca51bf1996328">repast::BaseGrid&lt; RelogoAgent, MultipleOccupancy&lt; RelogoAgent, int &gt;, GPTransformer, Adder, int &gt;</a>, and <a class="el" href="classrepast_1_1_base_grid.html#a21d840f3eb758b8f223ca51bf1996328">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, int &gt;, GPTransformer, Adder, int &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ab1ff08ad641de4f74eab53e30ad14eb6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classrepast_1_1_grid.html">repast::Grid</a>&lt; T, GPType &gt;::getRequiredAgents </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>agentsToTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>agentsRequired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RADIUS&#160;</td>
          <td class="paramname"><em>radius</em> = <code><a class="el" href="classrepast_1_1_projection.html">Projection</a>&lt;&#160;T&#160;&gt;::PRIMARY</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a set of agents to test, gets the subset that must be kept in order to fulfill the projection's 'contract' to the specified radius. </p>
<p>Generally spaces do not require any agents, but graphs do- generally the non-local ends to master copies of edges. </p>

<p>Implements <a class="el" href="classrepast_1_1_projection.html#ad13ded8db8e364aa43efde5b35da9a65">repast::Projection&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a81e7eb612dabbf2fb4b3f1190cd92f88"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classrepast_1_1_grid.html">repast::Grid</a>&lt; T, GPType &gt;::isPeriodic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether or not this grid is periodic (i.e. </p>
<p>toroidal).</p>
<dl class="section return"><dt>Returns</dt><dd>true if this <a class="el" href="classrepast_1_1_grid.html" title="Abstract interface for Grids and ContinuousSpaces. ">Grid</a> is periodic, otherwise false. </dd></dl>

<p>Implemented in <a class="el" href="classrepast_1_1_base_grid.html#a4dd5ec33acc952ab136f5e2b9886771e">repast::BaseGrid&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a4dd5ec33acc952ab136f5e2b9886771e">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, double &gt;, GPTransformer, Adder, double &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a4dd5ec33acc952ab136f5e2b9886771e">repast::BaseGrid&lt; RelogoAgent, MultipleOccupancy&lt; RelogoAgent, double &gt;, GPTransformer, Adder, double &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a4dd5ec33acc952ab136f5e2b9886771e">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, GPType &gt;, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a4dd5ec33acc952ab136f5e2b9886771e">repast::BaseGrid&lt; RelogoAgent, MultipleOccupancy&lt; RelogoAgent, int &gt;, GPTransformer, Adder, int &gt;</a>, and <a class="el" href="classrepast_1_1_base_grid.html#a4dd5ec33acc952ab136f5e2b9886771e">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, int &gt;, GPTransformer, Adder, int &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aa46a5e7692430604bb3b04bbb9e2ff50"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classrepast_1_1_grid.html">repast::Grid</a>&lt; T, GPType &gt;::keepsAgentsOnSyncProj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Should return true if the <a class="el" href="classrepast_1_1_projection.html" title="Abstract base class for all Projections. ">Projection</a> implemented can 'keep' some (non-local) agents during a projection information synchronization operation. </p>
<p>Generally spaces will allow all non-local agents to be deleted, but graphs keep the non-local agents that participate in Master edges.</p>
<p>It is possible to override these. A graph projection can be created that does not permit non-local agents to be 'kept'. This would be an extremely unusual use case, but it is possible.</p>
<p>Note that these are used for optimization. If no projection in a given context keeps any agents, several steps in the synchronization algorithm can be omitted. Of course, omitting these steps when a projection actually retains agents can caused undefined problems.</p>
<dl class="section return"><dt>Returns</dt><dd>true if this projection will keep non-local agents during a projection information synchronziation event, false if it will not. </dd></dl>

<p>Implements <a class="el" href="classrepast_1_1_projection.html#a1da1dcc47517e3e25be129067b21601f">repast::Projection&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a20efd6bdadf8dac405542de7e33f6b9e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::pair&lt;bool, <a class="el" href="classrepast_1_1_point.html">Point</a>&lt;GPType&gt; &gt; <a class="el" href="classrepast_1_1_grid.html">repast::Grid</a>&lt; T, GPType &gt;::moveByDisplacement </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>agent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; GPType &gt; &amp;&#160;</td>
          <td class="paramname"><em>displacement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the specified object from its current location by the specified amount. </p>
<p>For example <code>moveByDisplacement(object, 3, -2, 1)</code> will move the object by 3 along the x-axis, -2 along the y and 1 along the z. The displacement argument can be less than the number of dimensions in the space in which case the remaining argument will be set to 0. For example, <code>moveByDisplacement(object, 3)</code> will move the object 3 along the x-axis and 0 along the y and z axes, assuming a 3D grid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">agent</td><td>the object to move </td></tr>
    <tr><td class="paramname">displacement</td><td>the amount to move the object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair containing a bool that indicates whether the move was a success or not, and the point where the agent was moved to. </dd></dl>

<p>Implemented in <a class="el" href="classrepast_1_1_base_grid.html#a75758e9f795679c0a9c9b92fbd9413af">repast::BaseGrid&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a75758e9f795679c0a9c9b92fbd9413af">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, double &gt;, GPTransformer, Adder, double &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a75758e9f795679c0a9c9b92fbd9413af">repast::BaseGrid&lt; RelogoAgent, MultipleOccupancy&lt; RelogoAgent, double &gt;, GPTransformer, Adder, double &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a75758e9f795679c0a9c9b92fbd9413af">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, GPType &gt;, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a75758e9f795679c0a9c9b92fbd9413af">repast::BaseGrid&lt; RelogoAgent, MultipleOccupancy&lt; RelogoAgent, int &gt;, GPTransformer, Adder, int &gt;</a>, and <a class="el" href="classrepast_1_1_base_grid.html#a75758e9f795679c0a9c9b92fbd9413af">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, int &gt;, GPTransformer, Adder, int &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="adea1658b984c21ae95bd8f25ecb609b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::pair&lt;bool, <a class="el" href="classrepast_1_1_point.html">Point</a>&lt;GPType&gt; &gt; <a class="el" href="classrepast_1_1_grid.html">repast::Grid</a>&lt; T, GPType &gt;::moveByVector </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>agent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>anglesInRadians</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the specifed object the specified distance from its current position along the specified angle. </p>
<p>For example, <code>moveByVector(object, 1, Grid.NORTH)</code> will move the object 1 unit "north" up the y-axis, assuming a 2D grid. Similarly, <code>grid.moveByVector(object, 2, 0, Math.toRadians(90), 0)</code> will rotate 90 degrees around the y-axis, thus moving the object 2 units along the z-axis. </p>
<p><b> Note that the radians / degrees are incremented in a anti-clockwise fashion, such that 0 degrees is "east", 90 degrees is "north", 180 is "west" and 270 is "south."</b></p>
<p><b></p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">agent</td><td>the object to move </td></tr>
    <tr><td class="paramname">distance</td><td>the distance to move </td></tr>
    <tr><td class="paramname">anglesInRadians</td><td>the angle to move along in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair containing a bool that indicates whether the move was a success or not, and the point where the agent was moved to. </dd></dl>
<p></b></p>

<p>Implemented in <a class="el" href="classrepast_1_1_base_grid.html#a14de646e4c01d6bcd0356669a23af43d">repast::BaseGrid&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a14de646e4c01d6bcd0356669a23af43d">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, double &gt;, GPTransformer, Adder, double &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a14de646e4c01d6bcd0356669a23af43d">repast::BaseGrid&lt; RelogoAgent, MultipleOccupancy&lt; RelogoAgent, double &gt;, GPTransformer, Adder, double &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a14de646e4c01d6bcd0356669a23af43d">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, GPType &gt;, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a14de646e4c01d6bcd0356669a23af43d">repast::BaseGrid&lt; RelogoAgent, MultipleOccupancy&lt; RelogoAgent, int &gt;, GPTransformer, Adder, int &gt;</a>, and <a class="el" href="classrepast_1_1_base_grid.html#a14de646e4c01d6bcd0356669a23af43d">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, int &gt;, GPTransformer, Adder, int &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ae5bf061d62f1998e0c75bf3967ac63d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classrepast_1_1_grid.html">repast::Grid</a>&lt; T, GPType &gt;::moveTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the specified agent to the specified point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the id of the agent to move </td></tr>
    <tr><td class="paramname">pt</td><td>where to move the agent to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the move was successful, otherwise false </dd></dl>

<p>Implemented in <a class="el" href="classrepast_1_1_shared_base_grid.html#ab4d74c36e126cffa5638aeaab6c0df85">repast::SharedBaseGrid&lt; T, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_shared_base_grid.html#ab4d74c36e126cffa5638aeaab6c0df85">repast::SharedBaseGrid&lt; RelogoAgent, GPTransformer, Adder, int &gt;</a>, <a class="el" href="classrepast_1_1_shared_base_grid.html#ab4d74c36e126cffa5638aeaab6c0df85">repast::SharedBaseGrid&lt; T, GPTransformer, Adder, int &gt;</a>, <a class="el" href="classrepast_1_1_shared_base_grid.html#ab4d74c36e126cffa5638aeaab6c0df85">repast::SharedBaseGrid&lt; T, GPTransformer, Adder, double &gt;</a>, <a class="el" href="classrepast_1_1_shared_base_grid.html#ab4d74c36e126cffa5638aeaab6c0df85">repast::SharedBaseGrid&lt; RelogoAgent, GPTransformer, Adder, double &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a9f3dbdfe875327dbcc069971de98bc83">repast::BaseGrid&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a9f3dbdfe875327dbcc069971de98bc83">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, double &gt;, GPTransformer, Adder, double &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a9f3dbdfe875327dbcc069971de98bc83">repast::BaseGrid&lt; RelogoAgent, MultipleOccupancy&lt; RelogoAgent, double &gt;, GPTransformer, Adder, double &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a9f3dbdfe875327dbcc069971de98bc83">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, GPType &gt;, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#a9f3dbdfe875327dbcc069971de98bc83">repast::BaseGrid&lt; RelogoAgent, MultipleOccupancy&lt; RelogoAgent, int &gt;, GPTransformer, Adder, int &gt;</a>, and <a class="el" href="classrepast_1_1_base_grid.html#a9f3dbdfe875327dbcc069971de98bc83">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, int &gt;, GPTransformer, Adder, int &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ae3b7e2de573a9212a58a527a9ab519b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classrepast_1_1_grid.html">repast::Grid</a>&lt; T, GPType &gt;::sendsSecondaryAgentsOnStatusExchange </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Should return true if the <a class="el" href="classrepast_1_1_projection.html" title="Abstract base class for all Projections. ">Projection</a> implemented will send secondary agents during a status exchange. </p>
<p>Generally spaces do not and graphs do.</p>
<p>If no secondary agents will be sent, portions of the algorithm can be omitted for optimization.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="classrepast_1_1_projection.html" title="Abstract base class for all Projections. ">Projection</a> returns secondary agents, false if not </dd></dl>

<p>Implements <a class="el" href="classrepast_1_1_projection.html#a686c52a83dd917e50b04f81dc7321ad7">repast::Projection&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a001bf75cd2e436112555a5f992d1d372"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classrepast_1_1_grid.html">repast::Grid</a>&lt; T, GPType &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; GPType &gt; &amp;&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; GPType &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms the specified location using the properties (e.g. </p>
<p>toroidal) of this space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">location</td><td>the location to transform </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>the vector where the result of the transform will be put </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classrepast_1_1_base_grid.html#abe3c51f54b40e50e5e2b92b0b1b8e0de">repast::BaseGrid&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#abe3c51f54b40e50e5e2b92b0b1b8e0de">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, double &gt;, GPTransformer, Adder, double &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#abe3c51f54b40e50e5e2b92b0b1b8e0de">repast::BaseGrid&lt; RelogoAgent, MultipleOccupancy&lt; RelogoAgent, double &gt;, GPTransformer, Adder, double &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#abe3c51f54b40e50e5e2b92b0b1b8e0de">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, GPType &gt;, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#abe3c51f54b40e50e5e2b92b0b1b8e0de">repast::BaseGrid&lt; RelogoAgent, MultipleOccupancy&lt; RelogoAgent, int &gt;, GPTransformer, Adder, int &gt;</a>, and <a class="el" href="classrepast_1_1_base_grid.html#abe3c51f54b40e50e5e2b92b0b1b8e0de">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, int &gt;, GPTransformer, Adder, int &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a5aa30c315b9a32830b804d2e49af14d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classrepast_1_1_grid.html">repast::Grid</a>&lt; T, GPType &gt;::translate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;&#160;</td>
          <td class="paramname"><em>displacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; GPType &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translates the specified location by the specified displacement put the result in out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">location</td><td>the initial location </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">displacement</td><td>the amount to translate the location by </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>the vector where the result of the translation is put </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classrepast_1_1_base_grid.html#aa5607ff3f29ed7478f0de1d6884e0d7e">repast::BaseGrid&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#aa5607ff3f29ed7478f0de1d6884e0d7e">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, double &gt;, GPTransformer, Adder, double &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#aa5607ff3f29ed7478f0de1d6884e0d7e">repast::BaseGrid&lt; RelogoAgent, MultipleOccupancy&lt; RelogoAgent, double &gt;, GPTransformer, Adder, double &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#aa5607ff3f29ed7478f0de1d6884e0d7e">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, GPType &gt;, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_base_grid.html#aa5607ff3f29ed7478f0de1d6884e0d7e">repast::BaseGrid&lt; RelogoAgent, MultipleOccupancy&lt; RelogoAgent, int &gt;, GPTransformer, Adder, int &gt;</a>, and <a class="el" href="classrepast_1_1_base_grid.html#aa5607ff3f29ed7478f0de1d6884e0d7e">repast::BaseGrid&lt; T, MultipleOccupancy&lt; T, int &gt;, GPTransformer, Adder, int &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/nick/Documents/repos/repast-hpc/src/repast_hpc/<a class="el" href="_grid_8h_source.html">Grid.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Sep 28 2016 11:11:31 for RepastHPC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
