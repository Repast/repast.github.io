<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>RepastHPC: repast::Graph&lt; V, E, Ec, EcM &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RepastHPC
   &#160;<span id="projectnumber">2.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>repast</b></li><li class="navelem"><a class="el" href="classrepast_1_1_graph.html">Graph</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classrepast_1_1_graph-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">repast::Graph&lt; V, E, Ec, EcM &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classrepast_1_1_graph.html" title="Graph / Network implementation where agents are vertices in the graph. ">Graph</a> / Network implementation where agents are vertices in the graph.  
 <a href="classrepast_1_1_graph.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_graph_8h_source.html">Graph.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for repast::Graph&lt; V, E, Ec, EcM &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classrepast_1_1_graph.png" usemap="#repast::Graph_3C_20V_2C_20E_2C_20Ec_2C_20EcM_20_3E_map" alt=""/>
  <map id="repast::Graph_3C_20V_2C_20E_2C_20Ec_2C_20EcM_20_3E_map" name="repast::Graph&lt; V, E, Ec, EcM &gt;_map">
<area href="classrepast_1_1_projection.html" alt="repast::Projection&lt; V &gt;" shape="rect" coords="0,56,249,80"/>
<area href="classrepast_1_1_shared_network.html" title="Network implementation that can be shared across processes. " alt="repast::SharedNetwork&lt; V, E, Ec, EcM &gt;" shape="rect" coords="0,168,249,192"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:acee609459f11e02371ae4d8d226aafab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acee609459f11e02371ae4d8d226aafab"></a>
typedef boost::transform_iterator&lt; <a class="el" href="structrepast_1_1_node_getter.html">NodeGetter</a>&lt; V, E &gt;, typename VertexMap::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_graph.html#acee609459f11e02371ae4d8d226aafab">vertex_iterator</a></td></tr>
<tr class="memdesc:acee609459f11e02371ae4d8d226aafab"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator over the agents that are the vertices in this <a class="el" href="classrepast_1_1_graph.html" title="Graph / Network implementation where agents are vertices in the graph. ">Graph</a>. <br /></td></tr>
<tr class="separator:acee609459f11e02371ae4d8d226aafab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classrepast_1_1_projection"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classrepast_1_1_projection')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classrepast_1_1_projection.html">repast::Projection&lt; V &gt;</a></td></tr>
<tr class="memitem:ad4e03ba91fa58d03596836c6d76d5c80 inherit pub_types_classrepast_1_1_projection"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4e03ba91fa58d03596836c6d76d5c80"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>RADIUS</b> </td></tr>
<tr class="separator:ad4e03ba91fa58d03596836c6d76d5c80 inherit pub_types_classrepast_1_1_projection"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae2a9ad624d6fd581450243cd49e4ffe2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_graph.html#ae2a9ad624d6fd581450243cd49e4ffe2">Graph</a> (std::string <a class="el" href="classrepast_1_1_projection.html#ab60a0ab4f584685780307d7431b61800">name</a>, bool directed, EcM *edgeContentMgr)</td></tr>
<tr class="memdesc:ae2a9ad624d6fd581450243cd49e4ffe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classrepast_1_1_graph.html" title="Graph / Network implementation where agents are vertices in the graph. ">Graph</a> with the specified name.  <a href="#ae2a9ad624d6fd581450243cd49e4ffe2">More...</a><br /></td></tr>
<tr class="separator:ae2a9ad624d6fd581450243cd49e4ffe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e5b7105b55f1e967dff196e83a1621"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9e5b7105b55f1e967dff196e83a1621"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_graph.html#ad9e5b7105b55f1e967dff196e83a1621">Graph</a> (const <a class="el" href="classrepast_1_1_graph.html">Graph</a>&lt; V, E, Ec, EcM &gt; &amp;graph)</td></tr>
<tr class="memdesc:ad9e5b7105b55f1e967dff196e83a1621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor for the graph. <br /></td></tr>
<tr class="separator:ad9e5b7105b55f1e967dff196e83a1621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2404ed301bcecb8af4d1d45bd5de4c8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2404ed301bcecb8af4d1d45bd5de4c8a"></a>
<a class="el" href="classrepast_1_1_graph.html">Graph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classrepast_1_1_graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="separator:a2404ed301bcecb8af4d1d45bd5de4c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce027bc5e1c0119f9cce87aadf49bb7"><td class="memItemLeft" align="right" valign="top">virtual boost::shared_ptr&lt; E &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_graph.html#a7ce027bc5e1c0119f9cce87aadf49bb7">addEdge</a> (V *source, V *target)</td></tr>
<tr class="memdesc:a7ce027bc5e1c0119f9cce87aadf49bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an edge between source and target to this <a class="el" href="classrepast_1_1_graph.html" title="Graph / Network implementation where agents are vertices in the graph. ">Graph</a>.  <a href="#a7ce027bc5e1c0119f9cce87aadf49bb7">More...</a><br /></td></tr>
<tr class="separator:a7ce027bc5e1c0119f9cce87aadf49bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc7843398086080c064123aaf245dd5"><td class="memItemLeft" align="right" valign="top">virtual boost::shared_ptr&lt; E &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_graph.html#a9cc7843398086080c064123aaf245dd5">addEdge</a> (V *source, V *target, double weight)</td></tr>
<tr class="memdesc:a9cc7843398086080c064123aaf245dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an edge with the specified weight between source and target to this <a class="el" href="classrepast_1_1_graph.html" title="Graph / Network implementation where agents are vertices in the graph. ">Graph</a>.  <a href="#a9cc7843398086080c064123aaf245dd5">More...</a><br /></td></tr>
<tr class="separator:a9cc7843398086080c064123aaf245dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160050d2b0ce64a59b32c2697ddd622b"><td class="memItemLeft" align="right" valign="top">virtual boost::shared_ptr&lt; E &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_graph.html#a160050d2b0ce64a59b32c2697ddd622b">findEdge</a> (V *source, V *target)</td></tr>
<tr class="memdesc:a160050d2b0ce64a59b32c2697ddd622b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the edge between the source and target or 0 if no such edge is found.  <a href="#a160050d2b0ce64a59b32c2697ddd622b">More...</a><br /></td></tr>
<tr class="separator:a160050d2b0ce64a59b32c2697ddd622b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6eb280c2a2034f127453c5f965d61e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_graph.html#a9d6eb280c2a2034f127453c5f965d61e">successors</a> (V *vertex, std::vector&lt; V * &gt; &amp;out)</td></tr>
<tr class="memdesc:a9d6eb280c2a2034f127453c5f965d61e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sucessors of the specified vertex and puts them in out.  <a href="#a9d6eb280c2a2034f127453c5f965d61e">More...</a><br /></td></tr>
<tr class="separator:a9d6eb280c2a2034f127453c5f965d61e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9686c8fee74dbcb6b5bd0ddc9cc82827"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_graph.html#a9686c8fee74dbcb6b5bd0ddc9cc82827">predecessors</a> (V *vertex, std::vector&lt; V * &gt; &amp;out)</td></tr>
<tr class="memdesc:a9686c8fee74dbcb6b5bd0ddc9cc82827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the predecessors of the specified vertex and puts them in out.  <a href="#a9686c8fee74dbcb6b5bd0ddc9cc82827">More...</a><br /></td></tr>
<tr class="separator:a9686c8fee74dbcb6b5bd0ddc9cc82827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07ec9433947d5c677786e37e4cb0973"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_graph.html#ac07ec9433947d5c677786e37e4cb0973">adjacent</a> (V *vertex, std::vector&lt; V * &gt; &amp;out)</td></tr>
<tr class="memdesc:ac07ec9433947d5c677786e37e4cb0973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all the agent adjacent to the specified vertex.  <a href="#ac07ec9433947d5c677786e37e4cb0973">More...</a><br /></td></tr>
<tr class="separator:ac07ec9433947d5c677786e37e4cb0973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ddd223fa26a5390c13aa1c4fec9254"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_graph.html#a95ddd223fa26a5390c13aa1c4fec9254">removeEdge</a> (V *source, V *target)</td></tr>
<tr class="memdesc:a95ddd223fa26a5390c13aa1c4fec9254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the edge between source and target from this <a class="el" href="classrepast_1_1_graph.html" title="Graph / Network implementation where agents are vertices in the graph. ">Graph</a>.  <a href="#a95ddd223fa26a5390c13aa1c4fec9254">More...</a><br /></td></tr>
<tr class="separator:a95ddd223fa26a5390c13aa1c4fec9254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159360404f97fd8a7339ca98d13151cb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_graph.html#a159360404f97fd8a7339ca98d13151cb">removeEdge</a> (const <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &amp;source, const <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &amp;target)</td></tr>
<tr class="memdesc:a159360404f97fd8a7339ca98d13151cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the edge between source and target from this <a class="el" href="classrepast_1_1_graph.html" title="Graph / Network implementation where agents are vertices in the graph. ">Graph</a>.  <a href="#a159360404f97fd8a7339ca98d13151cb">More...</a><br /></td></tr>
<tr class="separator:a159360404f97fd8a7339ca98d13151cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f9c58855d8ba8ca197f695fdf5c6cc"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_graph.html#a00f9c58855d8ba8ca197f695fdf5c6cc">inDegree</a> (V *vertex)</td></tr>
<tr class="memdesc:a00f9c58855d8ba8ca197f695fdf5c6cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the in-degree of the specified vertex.  <a href="#a00f9c58855d8ba8ca197f695fdf5c6cc">More...</a><br /></td></tr>
<tr class="separator:a00f9c58855d8ba8ca197f695fdf5c6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca552decfd6069f132613c1f5aab59d"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_graph.html#aeca552decfd6069f132613c1f5aab59d">outDegree</a> (V *vertex)</td></tr>
<tr class="memdesc:aeca552decfd6069f132613c1f5aab59d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the out-degree of the specified vertex.  <a href="#aeca552decfd6069f132613c1f5aab59d">More...</a><br /></td></tr>
<tr class="separator:aeca552decfd6069f132613c1f5aab59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf15eede1ff417d8164f0eb4825cad09"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_graph.html#aaf15eede1ff417d8164f0eb4825cad09">edgeCount</a> () const </td></tr>
<tr class="memdesc:aaf15eede1ff417d8164f0eb4825cad09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of edges in this <a class="el" href="classrepast_1_1_graph.html" title="Graph / Network implementation where agents are vertices in the graph. ">Graph</a>.  <a href="#aaf15eede1ff417d8164f0eb4825cad09">More...</a><br /></td></tr>
<tr class="separator:aaf15eede1ff417d8164f0eb4825cad09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e0b0fc607154387d60596465c8fb80"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_graph.html#ae9e0b0fc607154387d60596465c8fb80">vertexCount</a> () const </td></tr>
<tr class="memdesc:ae9e0b0fc607154387d60596465c8fb80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of vertices in this <a class="el" href="classrepast_1_1_graph.html" title="Graph / Network implementation where agents are vertices in the graph. ">Graph</a>.  <a href="#ae9e0b0fc607154387d60596465c8fb80">More...</a><br /></td></tr>
<tr class="separator:ae9e0b0fc607154387d60596465c8fb80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc3dafd7087984a83ac0190e5058c5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrepast_1_1_graph.html#acee609459f11e02371ae4d8d226aafab">vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_graph.html#abbc3dafd7087984a83ac0190e5058c5b">verticesBegin</a> ()</td></tr>
<tr class="memdesc:abbc3dafd7087984a83ac0190e5058c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the start of an iterator over all the vertices in this graph.  <a href="#abbc3dafd7087984a83ac0190e5058c5b">More...</a><br /></td></tr>
<tr class="separator:abbc3dafd7087984a83ac0190e5058c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd76c847169c86e1e981100e8cf896f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrepast_1_1_graph.html#acee609459f11e02371ae4d8d226aafab">vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_graph.html#acd76c847169c86e1e981100e8cf896f0">verticesEnd</a> ()</td></tr>
<tr class="memdesc:acd76c847169c86e1e981100e8cf896f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the end of an iterator over all the vertices in this graph.  <a href="#acd76c847169c86e1e981100e8cf896f0">More...</a><br /></td></tr>
<tr class="separator:acd76c847169c86e1e981100e8cf896f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bfd1ab5fde73c290df15318746831f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2bfd1ab5fde73c290df15318746831f5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>showEdges</b> ()</td></tr>
<tr class="separator:a2bfd1ab5fde73c290df15318746831f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2f3ff6eb7d2975ed29cadcdd532b49"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c2f3ff6eb7d2975ed29cadcdd532b49"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>isMaster</b> (E *e)=0</td></tr>
<tr class="separator:a8c2f3ff6eb7d2975ed29cadcdd532b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedaa8e44eb04056df2acabbeba373201"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_graph.html#aedaa8e44eb04056df2acabbeba373201">keepsAgentsOnSyncProj</a> ()</td></tr>
<tr class="memdesc:aedaa8e44eb04056df2acabbeba373201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should return true if the <a class="el" href="classrepast_1_1_projection.html" title="Abstract base class for all Projections. ">Projection</a> implemented can 'keep' some (non-local) agents during a projection information synchronization operation.  <a href="#aedaa8e44eb04056df2acabbeba373201">More...</a><br /></td></tr>
<tr class="separator:aedaa8e44eb04056df2acabbeba373201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80cd467aae6d5e2c381bbe9cade6cbba"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_graph.html#a80cd467aae6d5e2c381bbe9cade6cbba">sendsSecondaryAgentsOnStatusExchange</a> ()</td></tr>
<tr class="memdesc:a80cd467aae6d5e2c381bbe9cade6cbba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should return true if the <a class="el" href="classrepast_1_1_projection.html" title="Abstract base class for all Projections. ">Projection</a> implemented will send secondary agents during a status exchange.  <a href="#a80cd467aae6d5e2c381bbe9cade6cbba">More...</a><br /></td></tr>
<tr class="separator:a80cd467aae6d5e2c381bbe9cade6cbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4200382f280c05f020611428507a134"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_graph.html#ab4200382f280c05f020611428507a134">getInfoExchangePartners</a> (std::set&lt; int &gt; &amp;psToSendTo, std::set&lt; int &gt; &amp;psToReceiveFrom)</td></tr>
<tr class="memdesc:ab4200382f280c05f020611428507a134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the set of processes with which this <a class="el" href="classrepast_1_1_projection.html" title="Abstract base class for all Projections. ">Projection</a> exchanges projection info.  <a href="#ab4200382f280c05f020611428507a134">More...</a><br /></td></tr>
<tr class="separator:ab4200382f280c05f020611428507a134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9a52d6d45473260e2771fe426c8a15"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_graph.html#a3e9a52d6d45473260e2771fe426c8a15">getAgentStatusExchangePartners</a> (std::set&lt; int &gt; &amp;psToSendTo, std::set&lt; int &gt; &amp;psToReceiveFrom)</td></tr>
<tr class="memdesc:a3e9a52d6d45473260e2771fe426c8a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the set of processes with which this <a class="el" href="classrepast_1_1_projection.html" title="Abstract base class for all Projections. ">Projection</a> exchanges agent status info- that is, the set of processes from which agents can move to this one or to which they can move when moving from this one.  <a href="#a3e9a52d6d45473260e2771fe426c8a15">More...</a><br /></td></tr>
<tr class="separator:a3e9a52d6d45473260e2771fe426c8a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3cffccc052f93d644a0d58630577ea0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3cffccc052f93d644a0d58630577ea0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_graph.html#ad3cffccc052f93d644a0d58630577ea0">getProjectionInfo</a> (std::vector&lt; <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &gt; &amp;agents, std::vector&lt; <a class="el" href="classrepast_1_1_projection_info_packet.html">ProjectionInfoPacket</a> * &gt; &amp;packets, bool secondaryInfo=false, std::set&lt; <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &gt; *secondaryIds=0, int destProc=-1)</td></tr>
<tr class="memdesc:ad3cffccc052f93d644a0d58630577ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper that gets all of the projection information for the agents specified (calls implementation in child class that gets only the information for one agent). <br /></td></tr>
<tr class="separator:ad3cffccc052f93d644a0d58630577ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd792216213093f9fea3b676d10ccdc7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd792216213093f9fea3b676d10ccdc7"></a>
virtual <a class="el" href="classrepast_1_1_projection_info_packet.html">ProjectionInfoPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getProjectionInfo</b> (<a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> id, bool secondaryInfo=false, std::set&lt; <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &gt; *secondaryIds=0, int destProc=-1)</td></tr>
<tr class="separator:acd792216213093f9fea3b676d10ccdc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a011ae319ca66af55a4131e3ce7804"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1a011ae319ca66af55a4131e3ce7804"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>updateProjectionInfo</b> (<a class="el" href="classrepast_1_1_projection_info_packet.html">ProjectionInfoPacket</a> *pip, <a class="el" href="classrepast_1_1_context.html">Context</a>&lt; V &gt; *context)</td></tr>
<tr class="separator:ad1a011ae319ca66af55a4131e3ce7804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af53ecedb239116dfe1a978fdfb1d364c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af53ecedb239116dfe1a978fdfb1d364c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>getRequiredAgents</b> (std::set&lt; <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &gt; &amp;agentsToTest, std::set&lt; <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &gt; &amp;agentsRequired, RADIUS radius=<a class="el" href="classrepast_1_1_projection.html">Projection</a>&lt; V &gt;::PRIMARY)</td></tr>
<tr class="separator:af53ecedb239116dfe1a978fdfb1d364c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011c1f0f065e5b8238c6783966c380eb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_graph.html#a011c1f0f065e5b8238c6783966c380eb">getAgentsToPush</a> (std::set&lt; <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &gt; &amp;agentsToTest, std::map&lt; int, std::set&lt; <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &gt; &gt; &amp;agentsToPush)</td></tr>
<tr class="memdesc:a011c1f0f065e5b8238c6783966c380eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of agents, gets the agents that this projection implementation must 'push' to other processes.  <a href="#a011c1f0f065e5b8238c6783966c380eb">More...</a><br /></td></tr>
<tr class="separator:a011c1f0f065e5b8238c6783966c380eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa24c44da950218515a28a9ebae26c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fa24c44da950218515a28a9ebae26c0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>cleanProjectionInfo</b> (std::set&lt; <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &gt; &amp;agentsToKeep)</td></tr>
<tr class="separator:a2fa24c44da950218515a28a9ebae26c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3c1f6c8031633d866eed178b5556e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae3c1f6c8031633d866eed178b5556e7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearConflictedEdges</b> ()</td></tr>
<tr class="separator:aae3c1f6c8031633d866eed178b5556e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ecd9032c3380032e5e387b421540b72"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ecd9032c3380032e5e387b421540b72"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>getConflictedEdges</b> (std::set&lt; boost::shared_ptr&lt; E &gt; &gt; &amp;conflictedEdges)</td></tr>
<tr class="separator:a4ecd9032c3380032e5e387b421540b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classrepast_1_1_projection"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classrepast_1_1_projection')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classrepast_1_1_projection.html">repast::Projection&lt; V &gt;</a></td></tr>
<tr class="memitem:ae89c14a3463d292ba1cd829204fbee71 inherit pub_methods_classrepast_1_1_projection"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae89c14a3463d292ba1cd829204fbee71"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_projection.html#ae89c14a3463d292ba1cd829204fbee71">updateProjectionInfo</a> (std::vector&lt; <a class="el" href="classrepast_1_1_projection_info_packet.html">ProjectionInfoPacket</a> * &gt; &amp;pips, <a class="el" href="classrepast_1_1_context.html">Context</a>&lt; V &gt; *context)</td></tr>
<tr class="memdesc:ae89c14a3463d292ba1cd829204fbee71 inherit pub_methods_classrepast_1_1_projection"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the projection information for the agents in this projection according to the information contained in the vector of information packets passed. <br /></td></tr>
<tr class="separator:ae89c14a3463d292ba1cd829204fbee71 inherit pub_methods_classrepast_1_1_projection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5c9f33cf57c5e7a00402eab2080051 inherit pub_methods_classrepast_1_1_projection"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_projection.html#a2c5c9f33cf57c5e7a00402eab2080051">Projection</a> (std::string <a class="el" href="classrepast_1_1_projection.html#ab60a0ab4f584685780307d7431b61800">name</a>)</td></tr>
<tr class="memdesc:a2c5c9f33cf57c5e7a00402eab2080051 inherit pub_methods_classrepast_1_1_projection"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a projection with specified name.  <a href="#a2c5c9f33cf57c5e7a00402eab2080051">More...</a><br /></td></tr>
<tr class="separator:a2c5c9f33cf57c5e7a00402eab2080051 inherit pub_methods_classrepast_1_1_projection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab60a0ab4f584685780307d7431b61800 inherit pub_methods_classrepast_1_1_projection"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab60a0ab4f584685780307d7431b61800"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_projection.html#ab60a0ab4f584685780307d7431b61800">name</a> () const</td></tr>
<tr class="memdesc:ab60a0ab4f584685780307d7431b61800 inherit pub_methods_classrepast_1_1_projection"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name of this projection. <br /></td></tr>
<tr class="separator:ab60a0ab4f584685780307d7431b61800 inherit pub_methods_classrepast_1_1_projection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340bcbf86f1e29489b9ca1a4aa5e9298 inherit pub_methods_classrepast_1_1_projection"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_projection.html#a340bcbf86f1e29489b9ca1a4aa5e9298">addFilterVal</a> (int type)</td></tr>
<tr class="memdesc:a340bcbf86f1e29489b9ca1a4aa5e9298 inherit pub_methods_classrepast_1_1_projection"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an entry to the list of agent types that can be added to this projection.  <a href="#a340bcbf86f1e29489b9ca1a4aa5e9298">More...</a><br /></td></tr>
<tr class="separator:a340bcbf86f1e29489b9ca1a4aa5e9298 inherit pub_methods_classrepast_1_1_projection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4587f793b1c250de22af16fedf7f89d inherit pub_methods_classrepast_1_1_projection"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_projection.html#ab4587f793b1c250de22af16fedf7f89d">removeFilterVal</a> (int type)</td></tr>
<tr class="memdesc:ab4587f793b1c250de22af16fedf7f89d inherit pub_methods_classrepast_1_1_projection"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an entry from the list of agent types that can be added to this projection.  <a href="#ab4587f793b1c250de22af16fedf7f89d">More...</a><br /></td></tr>
<tr class="separator:ab4587f793b1c250de22af16fedf7f89d inherit pub_methods_classrepast_1_1_projection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35eae2c3351ef0de242a2ebeac8719df inherit pub_methods_classrepast_1_1_projection"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35eae2c3351ef0de242a2ebeac8719df"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_projection.html#a35eae2c3351ef0de242a2ebeac8719df">clearFilter</a> ()</td></tr>
<tr class="memdesc:a35eae2c3351ef0de242a2ebeac8719df inherit pub_methods_classrepast_1_1_projection"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the list of agent types that can be added to this projection; the result is that the filter is empty, and any agent can be added. <br /></td></tr>
<tr class="separator:a35eae2c3351ef0de242a2ebeac8719df inherit pub_methods_classrepast_1_1_projection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4075a777a46f27e978d376c90e74a409 inherit pub_methods_classrepast_1_1_projection"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_projection.html#a4075a777a46f27e978d376c90e74a409">agentCanBeAdded</a> (boost::shared_ptr&lt; V &gt; agent)</td></tr>
<tr class="memdesc:a4075a777a46f27e978d376c90e74a409 inherit pub_methods_classrepast_1_1_projection"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the agent can be added to the projection, which will be the case if the filter list is empty or if the agent's type is in the filter list.  <a href="#a4075a777a46f27e978d376c90e74a409">More...</a><br /></td></tr>
<tr class="separator:a4075a777a46f27e978d376c90e74a409 inherit pub_methods_classrepast_1_1_projection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13ded8db8e364aa43efde5b35da9a65 inherit pub_methods_classrepast_1_1_projection"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_projection.html#ad13ded8db8e364aa43efde5b35da9a65">getRequiredAgents</a> (std::set&lt; <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &gt; &amp;agentsToTest, std::set&lt; <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &gt; &amp;agentsRequired, RADIUS radius=PRIMARY)=0</td></tr>
<tr class="memdesc:ad13ded8db8e364aa43efde5b35da9a65 inherit pub_methods_classrepast_1_1_projection"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of agents to test, gets the subset that must be kept in order to fulfill the projection's 'contract' to the specified radius.  <a href="#ad13ded8db8e364aa43efde5b35da9a65">More...</a><br /></td></tr>
<tr class="separator:ad13ded8db8e364aa43efde5b35da9a65 inherit pub_methods_classrepast_1_1_projection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5cda203753da3d565d7839f92589e8 inherit pub_methods_classrepast_1_1_projection"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd5cda203753da3d565d7839f92589e8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>balance</b> ()</td></tr>
<tr class="separator:afd5cda203753da3d565d7839f92589e8 inherit pub_methods_classrepast_1_1_projection"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a26a275229c943860f7dcc8f12a819d51"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26a275229c943860f7dcc8f12a819d51"></a>
std::set&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ranksToSendProjInfoTo</b></td></tr>
<tr class="separator:a26a275229c943860f7dcc8f12a819d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6bd3c93bc7fc980daee32416c62cef5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6bd3c93bc7fc980daee32416c62cef5"></a>
std::set&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ranksToReceiveProjInfoFrom</b></td></tr>
<tr class="separator:ac6bd3c93bc7fc980daee32416c62cef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ffbf7aafeaa71373c833215d6e7361"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6ffbf7aafeaa71373c833215d6e7361"></a>
std::set&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ranksToSendAgentStatusInfoTo</b></td></tr>
<tr class="separator:af6ffbf7aafeaa71373c833215d6e7361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6aa89bc4355dc7be2e9ffcf4831b69e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6aa89bc4355dc7be2e9ffcf4831b69e"></a>
std::set&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ranksToReceiveAgentStatusInfoFrom</b></td></tr>
<tr class="separator:ab6aa89bc4355dc7be2e9ffcf4831b69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71df0c0ac35f4464ff6d72f70bead983"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71df0c0ac35f4464ff6d72f70bead983"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>keepsAgents</b></td></tr>
<tr class="separator:a71df0c0ac35f4464ff6d72f70bead983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accec73ce11057ca4b5019b3693e93354"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="accec73ce11057ca4b5019b3693e93354"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>sendsSecondaryAgents</b></td></tr>
<tr class="separator:accec73ce11057ca4b5019b3693e93354"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a8d44d7ffee81310e667905eb64798228"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d44d7ffee81310e667905eb64798228"></a>
typedef boost::unordered_map&lt; <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a>, <a class="el" href="classrepast_1_1_vertex.html">Vertex</a>&lt; V, E &gt; *, <a class="el" href="structrepast_1_1_hash_id.html">HashId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>VertexMap</b></td></tr>
<tr class="separator:a8d44d7ffee81310e667905eb64798228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3e3741243a80c9d3732805b018ed00"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb3e3741243a80c9d3732805b018ed00"></a>
typedef VertexMap::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>VertexMapIterator</b></td></tr>
<tr class="separator:aeb3e3741243a80c9d3732805b018ed00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3c8e5132aa39f51bf64440e34f3e5c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c3c8e5132aa39f51bf64440e34f3e5c"></a>
typedef <a class="el" href="classrepast_1_1_projection.html">Projection</a>&lt; V &gt;::RADIUS&#160;</td><td class="memItemRight" valign="bottom"><b>RADIUS</b></td></tr>
<tr class="separator:a1c3c8e5132aa39f51bf64440e34f3e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ac355b765b3ebcaafb62603ded91fb170"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac355b765b3ebcaafb62603ded91fb170"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cleanUp</b> ()</td></tr>
<tr class="separator:ac355b765b3ebcaafb62603ded91fb170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb88d9a266f2dde1782f62f221479314"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb88d9a266f2dde1782f62f221479314"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>init</b> (const <a class="el" href="classrepast_1_1_graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="separator:abb88d9a266f2dde1782f62f221479314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6a71c186e6acbe4e04dcd1a866712d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab6a71c186e6acbe4e04dcd1a866712d"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>addAgent</b> (boost::shared_ptr&lt; V &gt; agent)</td></tr>
<tr class="separator:aab6a71c186e6acbe4e04dcd1a866712d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437e50a2ca1330b1bd3d582cf711b628"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a437e50a2ca1330b1bd3d582cf711b628"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>removeAgent</b> (V *agent)</td></tr>
<tr class="separator:a437e50a2ca1330b1bd3d582cf711b628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83187d1adf22e412f871102f5883df22"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83187d1adf22e412f871102f5883df22"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>doAddEdge</b> (boost::shared_ptr&lt; E &gt; edge, bool allowOverwrite=true)</td></tr>
<tr class="separator:a83187d1adf22e412f871102f5883df22"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a4cf91f79bf224e8550d31a500fc2a47a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4cf91f79bf224e8550d31a500fc2a47a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>edgeCount_</b></td></tr>
<tr class="separator:a4cf91f79bf224e8550d31a500fc2a47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31bc527fc394104d5d2252d7302e8bff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31bc527fc394104d5d2252d7302e8bff"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isDirected</b></td></tr>
<tr class="separator:a31bc527fc394104d5d2252d7302e8bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f010263d0a805926ff66e54dbd8ae5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12f010263d0a805926ff66e54dbd8ae5"></a>
VertexMap&#160;</td><td class="memItemRight" valign="bottom"><b>vertices</b></td></tr>
<tr class="separator:a12f010263d0a805926ff66e54dbd8ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4cab2042913e901d8a9eb2c170da6de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4cab2042913e901d8a9eb2c170da6de"></a>
EcM *&#160;</td><td class="memItemRight" valign="bottom"><b>edgeContentManager</b></td></tr>
<tr class="separator:ab4cab2042913e901d8a9eb2c170da6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classrepast_1_1_projection"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classrepast_1_1_projection')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classrepast_1_1_projection.html">repast::Projection&lt; V &gt;</a></td></tr>
<tr class="memitem:a374d61a05feb62c25e2046170fbd2be4 inherit pro_attribs_classrepast_1_1_projection"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a374d61a05feb62c25e2046170fbd2be4"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>name_</b></td></tr>
<tr class="separator:a374d61a05feb62c25e2046170fbd2be4 inherit pro_attribs_classrepast_1_1_projection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2db74e98e56396c2a129a7aefeb19e inherit pro_attribs_classrepast_1_1_projection"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade2db74e98e56396c2a129a7aefeb19e"></a>
std::set&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>filter</b></td></tr>
<tr class="separator:ade2db74e98e56396c2a129a7aefeb19e inherit pro_attribs_classrepast_1_1_projection"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename V, typename E, typename Ec, typename EcM&gt;<br />
class repast::Graph&lt; V, E, Ec, EcM &gt;</h3>

<p><a class="el" href="classrepast_1_1_graph.html" title="Graph / Network implementation where agents are vertices in the graph. ">Graph</a> / Network implementation where agents are vertices in the graph. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>the type agents in the graph. This type should extend <a class="el" href="classrepast_1_1_agent.html" title="Interface for agent classes. ">repast::Agent</a> </td></tr>
    <tr><td class="paramname">E</td><td>the edge type of the graph. This type should extend <a class="el" href="classrepast_1_1_repast_edge.html" title="Default graph / network edge implementation. ">repast::RepastEdge</a>. </td></tr>
    <tr><td class="paramname">Ec</td><td>class of serializable Edge Content </td></tr>
    <tr><td class="paramname">EcM</td><td>Class that is capable of transforming an Edge into Edge Content and vice versa </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae2a9ad624d6fd581450243cd49e4ffe2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V, typename E, typename Ec, typename EcM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrepast_1_1_graph.html">repast::Graph</a>&lt; V, E, Ec, EcM &gt;::<a class="el" href="classrepast_1_1_graph.html">Graph</a> </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>directed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EcM *&#160;</td>
          <td class="paramname"><em>edgeContentMgr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classrepast_1_1_graph.html" title="Graph / Network implementation where agents are vertices in the graph. ">Graph</a> with the specified name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the graph </td></tr>
    <tr><td class="paramname">directed</td><td>whether or not the created <a class="el" href="classrepast_1_1_graph.html" title="Graph / Network implementation where agents are vertices in the graph. ">Graph</a> is directed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7ce027bc5e1c0119f9cce87aadf49bb7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename E , typename Ec , typename EcM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt; E &gt; <a class="el" href="classrepast_1_1_graph.html">repast::Graph</a>&lt; V, E, Ec, EcM &gt;::addEdge </td>
          <td>(</td>
          <td class="paramtype">V *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an edge between source and target to this <a class="el" href="classrepast_1_1_graph.html" title="Graph / Network implementation where agents are vertices in the graph. ">Graph</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the source of the edge </td></tr>
    <tr><td class="paramname">target</td><td>the target of the edge</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the added edge. </dd></dl>

</div>
</div>
<a class="anchor" id="a9cc7843398086080c064123aaf245dd5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename E , typename Ec , typename EcM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt; E &gt; <a class="el" href="classrepast_1_1_graph.html">repast::Graph</a>&lt; V, E, Ec, EcM &gt;::addEdge </td>
          <td>(</td>
          <td class="paramtype">V *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an edge with the specified weight between source and target to this <a class="el" href="classrepast_1_1_graph.html" title="Graph / Network implementation where agents are vertices in the graph. ">Graph</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the source of the edge </td></tr>
    <tr><td class="paramname">target</td><td>the target of the edge </td></tr>
    <tr><td class="paramname">weight</td><td>the weight of the edge</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the added edge. </dd></dl>

</div>
</div>
<a class="anchor" id="ac07ec9433947d5c677786e37e4cb0973"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename E , typename Ec , typename EcM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrepast_1_1_graph.html">repast::Graph</a>&lt; V, E, Ec, EcM &gt;::adjacent </td>
          <td>(</td>
          <td class="paramtype">V *&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; V * &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets all the agent adjacent to the specified vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">vertex</td><td>the vertex whose adjacent agents we want to get </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">the</td><td>vector where the results will be put </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf15eede1ff417d8164f0eb4825cad09"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V, typename E, typename Ec, typename EcM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classrepast_1_1_graph.html">repast::Graph</a>&lt; V, E, Ec, EcM &gt;::edgeCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of edges in this <a class="el" href="classrepast_1_1_graph.html" title="Graph / Network implementation where agents are vertices in the graph. ">Graph</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of edges in this <a class="el" href="classrepast_1_1_graph.html" title="Graph / Network implementation where agents are vertices in the graph. ">Graph</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a160050d2b0ce64a59b32c2697ddd622b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename E , typename Ec , typename EcM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt; E &gt; <a class="el" href="classrepast_1_1_graph.html">repast::Graph</a>&lt; V, E, Ec, EcM &gt;::findEdge </td>
          <td>(</td>
          <td class="paramtype">V *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the edge between the source and target or 0 if no such edge is found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the source of the edge to find </td></tr>
    <tr><td class="paramname">target</td><td>the target of the edge to find</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the found edge or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a3e9a52d6d45473260e2771fe426c8a15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename E , typename Ec , typename EcM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrepast_1_1_graph.html">repast::Graph</a>&lt; V, E, Ec, EcM &gt;::getAgentStatusExchangePartners </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>psToSendTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>psToReceiveFrom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the set of processes with which this <a class="el" href="classrepast_1_1_projection.html" title="Abstract base class for all Projections. ">Projection</a> exchanges agent status info- that is, the set of processes from which agents can move to this one or to which they can move when moving from this one. </p>
<p>In the most general case this will be all other processors. However, simulations where agents move in spaces will usually exchange agents only with a small subset of 'neighbor' processes, which is knowable in advance and constant. To accommodate the general case, the algorithm for exchanging information must poll all other processes to see which are sending to this one; if this is known in advance, this additional (expensive) step can be skipped. </p>

<p>Implements <a class="el" href="classrepast_1_1_projection.html#ad2d104bb6119d0911053d450932855d5">repast::Projection&lt; V &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a011c1f0f065e5b8238c6783966c380eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename E , typename Ec , typename EcM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrepast_1_1_graph.html">repast::Graph</a>&lt; V, E, Ec, EcM &gt;::getAgentsToPush </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>agentsToTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; int, std::set&lt; <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>agentsToPush</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a set of agents, gets the agents that this projection implementation must 'push' to other processes. </p>
<p>Generally spaces must push agents that are in 'buffer zones' and graphs must push local agents that are vertices to master edges where the other vertex is non- local. The results are returned per-process in the agentsToPush map. </p>

<p>Implements <a class="el" href="classrepast_1_1_projection.html#ae1877809facd80a5e25d95e3dc5c35f4">repast::Projection&lt; V &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ab4200382f280c05f020611428507a134"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename E , typename Ec , typename EcM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrepast_1_1_graph.html">repast::Graph</a>&lt; V, E, Ec, EcM &gt;::getInfoExchangePartners </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>psToSendTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>psToReceiveFrom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the set of processes with which this <a class="el" href="classrepast_1_1_projection.html" title="Abstract base class for all Projections. ">Projection</a> exchanges projection info. </p>
<p>In the most general case this will be all other processors; this is the case for graphs, where agent connections can be arbitrary. However, spaces usually exchange information only with a small subset of 'neighbor' processes, which is knowable in advance and constant. To accommodate the general case, the algorithm for exchanging information must poll all other processes to see which are sending to this one; if this is known in advance, this additional (expensive) step can be skipped. </p>

<p>Implements <a class="el" href="classrepast_1_1_projection.html#afdc13fccb129094bfd67b3446873933d">repast::Projection&lt; V &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a00f9c58855d8ba8ca197f695fdf5c6cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename E , typename Ec , typename EcM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classrepast_1_1_graph.html">repast::Graph</a>&lt; V, E, Ec, EcM &gt;::inDegree </td>
          <td>(</td>
          <td class="paramtype">V *&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the in-degree of the specified vertex. </p>
<dl class="section return"><dt>Returns</dt><dd>the in-degree of the specified vertex. </dd></dl>

</div>
</div>
<a class="anchor" id="aedaa8e44eb04056df2acabbeba373201"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V, typename E, typename Ec, typename EcM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classrepast_1_1_graph.html">repast::Graph</a>&lt; V, E, Ec, EcM &gt;::keepsAgentsOnSyncProj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Should return true if the <a class="el" href="classrepast_1_1_projection.html" title="Abstract base class for all Projections. ">Projection</a> implemented can 'keep' some (non-local) agents during a projection information synchronization operation. </p>
<p>Generally spaces will allow all non-local agents to be deleted, but graphs keep the non-local agents that participate in Master edges.</p>
<p>It is possible to override these. A graph projection can be created that does not permit non-local agents to be 'kept'. This would be an extremely unusual use case, but it is possible.</p>
<p>Note that these are used for optimization. If no projection in a given context keeps any agents, several steps in the synchronization algorithm can be omitted. Of course, omitting these steps when a projection actually retains agents can caused undefined problems.</p>
<dl class="section return"><dt>Returns</dt><dd>true if this projection will keep non-local agents during a projection information synchronziation event, false if it will not. </dd></dl>

<p>Implements <a class="el" href="classrepast_1_1_projection.html#a1da1dcc47517e3e25be129067b21601f">repast::Projection&lt; V &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aeca552decfd6069f132613c1f5aab59d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename E , typename Ec , typename EcM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classrepast_1_1_graph.html">repast::Graph</a>&lt; V, E, Ec, EcM &gt;::outDegree </td>
          <td>(</td>
          <td class="paramtype">V *&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the out-degree of the specified vertex. </p>
<dl class="section return"><dt>Returns</dt><dd>the out-degree of the specified vertex. </dd></dl>

</div>
</div>
<a class="anchor" id="a9686c8fee74dbcb6b5bd0ddc9cc82827"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename E , typename Ec , typename EcM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrepast_1_1_graph.html">repast::Graph</a>&lt; V, E, Ec, EcM &gt;::predecessors </td>
          <td>(</td>
          <td class="paramtype">V *&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; V * &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the predecessors of the specified vertex and puts them in out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">vertex</td><td>the vertex whose predecessors we want to get </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">where</td><td>the predecessors will be returned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a95ddd223fa26a5390c13aa1c4fec9254"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename E , typename Ec , typename EcM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrepast_1_1_graph.html">repast::Graph</a>&lt; V, E, Ec, EcM &gt;::removeEdge </td>
          <td>(</td>
          <td class="paramtype">V *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the edge between source and target from this <a class="el" href="classrepast_1_1_graph.html" title="Graph / Network implementation where agents are vertices in the graph. ">Graph</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the source of the edge </td></tr>
    <tr><td class="paramname">target</td><td>the target of the edge </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classrepast_1_1_shared_network.html#a93396d324b570d7728cbe6ce3271173c">repast::SharedNetwork&lt; V, E, Ec, EcM &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a159360404f97fd8a7339ca98d13151cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename E , typename Ec , typename EcM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrepast_1_1_graph.html">repast::Graph</a>&lt; V, E, Ec, EcM &gt;::removeEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the edge between source and target from this <a class="el" href="classrepast_1_1_graph.html" title="Graph / Network implementation where agents are vertices in the graph. ">Graph</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the id of the vertex that is the source of the edge </td></tr>
    <tr><td class="paramname">target</td><td>the id of the vertex that is the target of the edge </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a80cd467aae6d5e2c381bbe9cade6cbba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V, typename E, typename Ec, typename EcM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classrepast_1_1_graph.html">repast::Graph</a>&lt; V, E, Ec, EcM &gt;::sendsSecondaryAgentsOnStatusExchange </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Should return true if the <a class="el" href="classrepast_1_1_projection.html" title="Abstract base class for all Projections. ">Projection</a> implemented will send secondary agents during a status exchange. </p>
<p>Generally spaces do not and graphs do.</p>
<p>If no secondary agents will be sent, portions of the algorithm can be omitted for optimization.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="classrepast_1_1_projection.html" title="Abstract base class for all Projections. ">Projection</a> returns secondary agents, false if not </dd></dl>

<p>Implements <a class="el" href="classrepast_1_1_projection.html#a686c52a83dd917e50b04f81dc7321ad7">repast::Projection&lt; V &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a9d6eb280c2a2034f127453c5f965d61e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename E , typename Ec , typename EcM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrepast_1_1_graph.html">repast::Graph</a>&lt; V, E, Ec, EcM &gt;::successors </td>
          <td>(</td>
          <td class="paramtype">V *&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; V * &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the sucessors of the specified vertex and puts them in out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">vertex</td><td>the vertex whose successors we want to get </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">where</td><td>the successors will be returned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae9e0b0fc607154387d60596465c8fb80"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V, typename E, typename Ec, typename EcM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classrepast_1_1_graph.html">repast::Graph</a>&lt; V, E, Ec, EcM &gt;::vertexCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of vertices in this <a class="el" href="classrepast_1_1_graph.html" title="Graph / Network implementation where agents are vertices in the graph. ">Graph</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of vertices in this <a class="el" href="classrepast_1_1_graph.html" title="Graph / Network implementation where agents are vertices in the graph. ">Graph</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="abbc3dafd7087984a83ac0190e5058c5b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V, typename E, typename Ec, typename EcM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrepast_1_1_graph.html#acee609459f11e02371ae4d8d226aafab">vertex_iterator</a> <a class="el" href="classrepast_1_1_graph.html">repast::Graph</a>&lt; V, E, Ec, EcM &gt;::verticesBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the start of an iterator over all the vertices in this graph. </p>
<p>The iterator dereferences to a pointer to agents of type V.</p>
<dl class="section return"><dt>Returns</dt><dd>the start of an iterator over all the vertices in this graph. </dd></dl>

</div>
</div>
<a class="anchor" id="acd76c847169c86e1e981100e8cf896f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V, typename E, typename Ec, typename EcM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrepast_1_1_graph.html#acee609459f11e02371ae4d8d226aafab">vertex_iterator</a> <a class="el" href="classrepast_1_1_graph.html">repast::Graph</a>&lt; V, E, Ec, EcM &gt;::verticesEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the end of an iterator over all the vertices in this graph. </p>
<p>The iterator dereferences to a pointer to agents of type V.</p>
<dl class="section return"><dt>Returns</dt><dd>the end of an iterator over all the vertices in this graph. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/nick/Documents/repos/repast-hpc/src/repast_hpc/<a class="el" href="_graph_8h_source.html">Graph.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Sep 28 2016 11:11:31 for RepastHPC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
