<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>RepastHPC: repast::BaseGrid&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RepastHPC
   &#160;<span id="projectnumber">2.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>repast</b></li><li class="navelem"><a class="el" href="classrepast_1_1_base_grid.html">BaseGrid</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classrepast_1_1_base_grid-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">repast::BaseGrid&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Base grid implementation, implementing elements common to both Grids and ContinuousSpaces.  
 <a href="classrepast_1_1_base_grid.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_base_grid_8h_source.html">BaseGrid.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for repast::BaseGrid&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classrepast_1_1_base_grid.png" usemap="#repast::BaseGrid_3C_20T_2C_20CellAccessor_2C_20GPTransformer_2C_20Adder_2C_20GPType_20_3E_map" alt=""/>
  <map id="repast::BaseGrid_3C_20T_2C_20CellAccessor_2C_20GPTransformer_2C_20Adder_2C_20GPType_20_3E_map" name="repast::BaseGrid&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;_map">
<area href="classrepast_1_1_grid.html" title="Abstract interface for Grids and ContinuousSpaces. " alt="repast::Grid&lt; T, GPType &gt;" shape="rect" coords="0,112,414,136"/>
<area href="classrepast_1_1_projection.html" title="Abstract base class for all Projections. " alt="repast::Projection&lt; T &gt;" shape="rect" coords="0,56,414,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae4de9c96ae3ee3d7021a1e5b3c61b9a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4de9c96ae3ee3d7021a1e5b3c61b9a6"></a>
typedef boost::transform_iterator&lt; <a class="el" href="structrepast_1_1_agent_from_grid_point.html">AgentFromGridPoint</a>&lt; T, GPType &gt;, LocationMapConstIter &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_base_grid.html#ae4de9c96ae3ee3d7021a1e5b3c61b9a6">const_iterator</a></td></tr>
<tr class="memdesc:ae4de9c96ae3ee3d7021a1e5b3c61b9a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const iterator over shared_ptr&lt;T&gt;. <br /></td></tr>
<tr class="separator:ae4de9c96ae3ee3d7021a1e5b3c61b9a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classrepast_1_1_projection"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classrepast_1_1_projection')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classrepast_1_1_projection.html">repast::Projection&lt; T &gt;</a></td></tr>
<tr class="memitem:ad4e03ba91fa58d03596836c6d76d5c80 inherit pub_types_classrepast_1_1_projection"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4e03ba91fa58d03596836c6d76d5c80"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>RADIUS</b> { <b>PRIMARY</b>, 
<b>SECONDARY</b>
 }</td></tr>
<tr class="separator:ad4e03ba91fa58d03596836c6d76d5c80 inherit pub_types_classrepast_1_1_projection"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a73eae15ca682e2c03a71392c29453d43"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_base_grid.html#a73eae15ca682e2c03a71392c29453d43">BaseGrid</a> (std::string <a class="el" href="classrepast_1_1_projection.html#ab60a0ab4f584685780307d7431b61800">name</a>, <a class="el" href="classrepast_1_1_grid_dimensions.html">GridDimensions</a> <a class="el" href="classrepast_1_1_base_grid.html#a5f8a2fc16b8aeba026a58fcb374cf05c">dimensions</a>)</td></tr>
<tr class="memdesc:a73eae15ca682e2c03a71392c29453d43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classrepast_1_1_base_grid.html" title="Base grid implementation, implementing elements common to both Grids and ContinuousSpaces. ">BaseGrid</a> with the specified name and dimensions.  <a href="#a73eae15ca682e2c03a71392c29453d43">More...</a><br /></td></tr>
<tr class="separator:a73eae15ca682e2c03a71392c29453d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648fcba07fdc15b4072b5807b4f1b6b0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_base_grid.html#a648fcba07fdc15b4072b5807b4f1b6b0">contains</a> (const <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &amp;id)</td></tr>
<tr class="memdesc:a648fcba07fdc15b4072b5807b4f1b6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether or not this grid contains the agent with the specified id.  <a href="#a648fcba07fdc15b4072b5807b4f1b6b0">More...</a><br /></td></tr>
<tr class="separator:a648fcba07fdc15b4072b5807b4f1b6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef8aae56bb771fa152b10408d718f6e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_base_grid.html#a9ef8aae56bb771fa152b10408d718f6e">getLocation</a> (const T *agent, std::vector&lt; GPType &gt; &amp;pt) const </td></tr>
<tr class="memdesc:a9ef8aae56bb771fa152b10408d718f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the location of this agent and puts it in the specified vector.  <a href="#a9ef8aae56bb771fa152b10408d718f6e">More...</a><br /></td></tr>
<tr class="separator:a9ef8aae56bb771fa152b10408d718f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18b424b73ff46fde970ad1e1bb3cdc4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_base_grid.html#aa18b424b73ff46fde970ad1e1bb3cdc4">getLocation</a> (const <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &amp;id, std::vector&lt; GPType &gt; &amp;out) const </td></tr>
<tr class="memdesc:aa18b424b73ff46fde970ad1e1bb3cdc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the location of this agent and puts it in the specified vectors.  <a href="#aa18b424b73ff46fde970ad1e1bb3cdc4">More...</a><br /></td></tr>
<tr class="separator:aa18b424b73ff46fde970ad1e1bb3cdc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3710f4aca96eeb3a95a44fe80e0c998a"><td class="memItemLeft" align="right" valign="top">virtual T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_base_grid.html#a3710f4aca96eeb3a95a44fe80e0c998a">getObjectAt</a> (const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;pt) const </td></tr>
<tr class="memdesc:a3710f4aca96eeb3a95a44fe80e0c998a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the first object found at the specified point, or NULL if there is no such object.  <a href="#a3710f4aca96eeb3a95a44fe80e0c998a">More...</a><br /></td></tr>
<tr class="separator:a3710f4aca96eeb3a95a44fe80e0c998a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d840f3eb758b8f223ca51bf1996328"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_base_grid.html#a21d840f3eb758b8f223ca51bf1996328">getObjectsAt</a> (const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;pt, std::vector&lt; T * &gt; &amp;out) const </td></tr>
<tr class="memdesc:a21d840f3eb758b8f223ca51bf1996328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all the objects found at the specified point.  <a href="#a21d840f3eb758b8f223ca51bf1996328">More...</a><br /></td></tr>
<tr class="separator:a21d840f3eb758b8f223ca51bf1996328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e9d1d23b2e9f4e3d40d87d92595693"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_base_grid.html#a40e9d1d23b2e9f4e3d40d87d92595693">moveTo</a> (const T *agent, const std::vector&lt; GPType &gt; &amp;newLocation)</td></tr>
<tr class="memdesc:a40e9d1d23b2e9f4e3d40d87d92595693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the specified agent to the specified location.  <a href="#a40e9d1d23b2e9f4e3d40d87d92595693">More...</a><br /></td></tr>
<tr class="separator:a40e9d1d23b2e9f4e3d40d87d92595693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f5499f55a0736c07ed87bb37caeae8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_base_grid.html#a60f5499f55a0736c07ed87bb37caeae8">moveTo</a> (const T *agent, const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;newLocation)</td></tr>
<tr class="memdesc:a60f5499f55a0736c07ed87bb37caeae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the specified agent to the specified location.  <a href="#a60f5499f55a0736c07ed87bb37caeae8">More...</a><br /></td></tr>
<tr class="separator:a60f5499f55a0736c07ed87bb37caeae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a39996218f4426aa1b2f081d3b44eb4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_base_grid.html#a3a39996218f4426aa1b2f081d3b44eb4">moveTo</a> (const <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &amp;id, const std::vector&lt; GPType &gt; &amp;newLocation)</td></tr>
<tr class="memdesc:a3a39996218f4426aa1b2f081d3b44eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the specified agent to the specified location.  <a href="#a3a39996218f4426aa1b2f081d3b44eb4">More...</a><br /></td></tr>
<tr class="separator:a3a39996218f4426aa1b2f081d3b44eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3dbdfe875327dbcc069971de98bc83"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_base_grid.html#a9f3dbdfe875327dbcc069971de98bc83">moveTo</a> (const <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &amp;id, const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;pt)</td></tr>
<tr class="memdesc:a9f3dbdfe875327dbcc069971de98bc83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the specified agent to the specified point.  <a href="#a9f3dbdfe875327dbcc069971de98bc83">More...</a><br /></td></tr>
<tr class="separator:a9f3dbdfe875327dbcc069971de98bc83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75758e9f795679c0a9c9b92fbd9413af"><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; bool, <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_base_grid.html#a75758e9f795679c0a9c9b92fbd9413af">moveByDisplacement</a> (const T *agent, const std::vector&lt; GPType &gt; &amp;displacement)</td></tr>
<tr class="memdesc:a75758e9f795679c0a9c9b92fbd9413af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the specified object from its current location by the specified amount.  <a href="#a75758e9f795679c0a9c9b92fbd9413af">More...</a><br /></td></tr>
<tr class="separator:a75758e9f795679c0a9c9b92fbd9413af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14de646e4c01d6bcd0356669a23af43d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14de646e4c01d6bcd0356669a23af43d"></a>
virtual std::pair&lt; bool, <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_base_grid.html#a14de646e4c01d6bcd0356669a23af43d">moveByVector</a> (const T *agent, double distance, const std::vector&lt; double &gt; &amp;anglesInRadians)</td></tr>
<tr class="memdesc:a14de646e4c01d6bcd0356669a23af43d"><td class="mdescLeft">&#160;</td><td class="mdescRight">doc inherited from <a class="el" href="classrepast_1_1_grid.html" title="Abstract interface for Grids and ContinuousSpaces. ">Grid</a> <br /></td></tr>
<tr class="separator:a14de646e4c01d6bcd0356669a23af43d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5aa5a65509879b528bac5b3a9f544b9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classrepast_1_1_base_grid.html#ae4de9c96ae3ee3d7021a1e5b3c61b9a6">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_base_grid.html#ab5aa5a65509879b528bac5b3a9f544b9">begin</a> () const </td></tr>
<tr class="memdesc:ab5aa5a65509879b528bac5b3a9f544b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an iterator over the agents in this <a class="el" href="classrepast_1_1_base_grid.html" title="Base grid implementation, implementing elements common to both Grids and ContinuousSpaces. ">BaseGrid</a> starting with the first agent.  <a href="#ab5aa5a65509879b528bac5b3a9f544b9">More...</a><br /></td></tr>
<tr class="separator:ab5aa5a65509879b528bac5b3a9f544b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7eced6c979ccf417b4bbc1c064c687d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classrepast_1_1_base_grid.html#ae4de9c96ae3ee3d7021a1e5b3c61b9a6">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_base_grid.html#ac7eced6c979ccf417b4bbc1c064c687d">end</a> () const </td></tr>
<tr class="memdesc:ac7eced6c979ccf417b4bbc1c064c687d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the end of an iterator over the agents in this <a class="el" href="classrepast_1_1_base_grid.html" title="Base grid implementation, implementing elements common to both Grids and ContinuousSpaces. ">BaseGrid</a>.  <a href="#ac7eced6c979ccf417b4bbc1c064c687d">More...</a><br /></td></tr>
<tr class="separator:ac7eced6c979ccf417b4bbc1c064c687d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1e81ffc9b8f581279a89abf1a4e62e1"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_base_grid.html#ab1e81ffc9b8f581279a89abf1a4e62e1">size</a> () const </td></tr>
<tr class="memdesc:ab1e81ffc9b8f581279a89abf1a4e62e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of agents in this <a class="el" href="classrepast_1_1_base_grid.html" title="Base grid implementation, implementing elements common to both Grids and ContinuousSpaces. ">BaseGrid</a>.  <a href="#ab1e81ffc9b8f581279a89abf1a4e62e1">More...</a><br /></td></tr>
<tr class="separator:ab1e81ffc9b8f581279a89abf1a4e62e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124b5f53a5e96e9ed8e59534e9417f42"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_base_grid.html#a124b5f53a5e96e9ed8e59534e9417f42">getDistance</a> (const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;pt1, const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;pt2) const </td></tr>
<tr class="memdesc:a124b5f53a5e96e9ed8e59534e9417f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the distance between the two grid points.  <a href="#a124b5f53a5e96e9ed8e59534e9417f42">More...</a><br /></td></tr>
<tr class="separator:a124b5f53a5e96e9ed8e59534e9417f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8075dd20e6d559d453a530943ab9d387"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_base_grid.html#a8075dd20e6d559d453a530943ab9d387">getDistanceSq</a> (const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;pt1, const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;pt2) const </td></tr>
<tr class="memdesc:a8075dd20e6d559d453a530943ab9d387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the square of the distance between the two grid points.  <a href="#a8075dd20e6d559d453a530943ab9d387">More...</a><br /></td></tr>
<tr class="separator:a8075dd20e6d559d453a530943ab9d387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3b8755d2fc2bf75163a0fc76ce1d4a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_base_grid.html#a8c3b8755d2fc2bf75163a0fc76ce1d4a">getDisplacement</a> (const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;pt1, const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;pt2, std::vector&lt; GPType &gt; &amp;out) const </td></tr>
<tr class="memdesc:a8c3b8755d2fc2bf75163a0fc76ce1d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets vector difference between point 1 and point 2, putting the result in out.  <a href="#a8c3b8755d2fc2bf75163a0fc76ce1d4a">More...</a><br /></td></tr>
<tr class="separator:a8c3b8755d2fc2bf75163a0fc76ce1d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8a2fc16b8aeba026a58fcb374cf05c"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classrepast_1_1_grid_dimensions.html">GridDimensions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_base_grid.html#a5f8a2fc16b8aeba026a58fcb374cf05c">dimensions</a> () const </td></tr>
<tr class="memdesc:a5f8a2fc16b8aeba026a58fcb374cf05c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the dimensions of this <a class="el" href="classrepast_1_1_grid.html" title="Abstract interface for Grids and ContinuousSpaces. ">Grid</a>.  <a href="#a5f8a2fc16b8aeba026a58fcb374cf05c">More...</a><br /></td></tr>
<tr class="separator:a5f8a2fc16b8aeba026a58fcb374cf05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5607ff3f29ed7478f0de1d6884e0d7e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_base_grid.html#aa5607ff3f29ed7478f0de1d6884e0d7e">translate</a> (const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;location, const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;displacement, std::vector&lt; GPType &gt; &amp;out) const </td></tr>
<tr class="memdesc:aa5607ff3f29ed7478f0de1d6884e0d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates the specified location by the specified displacement put the result in out.  <a href="#aa5607ff3f29ed7478f0de1d6884e0d7e">More...</a><br /></td></tr>
<tr class="separator:aa5607ff3f29ed7478f0de1d6884e0d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3c51f54b40e50e5e2b92b0b1b8e0de"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_base_grid.html#abe3c51f54b40e50e5e2b92b0b1b8e0de">transform</a> (const std::vector&lt; GPType &gt; &amp;location, std::vector&lt; GPType &gt; &amp;out) const </td></tr>
<tr class="memdesc:abe3c51f54b40e50e5e2b92b0b1b8e0de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the specified location using the properties (e.g.  <a href="#abe3c51f54b40e50e5e2b92b0b1b8e0de">More...</a><br /></td></tr>
<tr class="separator:abe3c51f54b40e50e5e2b92b0b1b8e0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd5ec33acc952ab136f5e2b9886771e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_base_grid.html#a4dd5ec33acc952ab136f5e2b9886771e">isPeriodic</a> () const </td></tr>
<tr class="memdesc:a4dd5ec33acc952ab136f5e2b9886771e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether or not this grid is periodic (i.e.  <a href="#a4dd5ec33acc952ab136f5e2b9886771e">More...</a><br /></td></tr>
<tr class="separator:a4dd5ec33acc952ab136f5e2b9886771e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51685b60fcfb3081007b22559225af8f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51685b60fcfb3081007b22559225af8f"></a>
virtual <a class="el" href="classrepast_1_1_projection_info_packet.html">ProjectionInfoPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getProjectionInfo</b> (<a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> id, bool secondaryInfo=false, std::set&lt; <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &gt; *secondaryIds=0, int destProc=-1)</td></tr>
<tr class="separator:a51685b60fcfb3081007b22559225af8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95c2c141f8b8365472c2f47df614554"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac95c2c141f8b8365472c2f47df614554"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>updateProjectionInfo</b> (<a class="el" href="classrepast_1_1_projection_info_packet.html">ProjectionInfoPacket</a> *pip, <a class="el" href="classrepast_1_1_context.html">Context</a>&lt; T &gt; *context)</td></tr>
<tr class="separator:ac95c2c141f8b8365472c2f47df614554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f718ade5af8285f71151eea824ce3cd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_base_grid.html#a8f718ade5af8285f71151eea824ce3cd">getAgentsToPush</a> (std::set&lt; <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &gt; &amp;agentsToTest, std::map&lt; int, std::set&lt; <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &gt; &gt; &amp;agentsToPush)</td></tr>
<tr class="memdesc:a8f718ade5af8285f71151eea824ce3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of agents, gets the agents that this projection implementation must 'push' to other processes.  <a href="#a8f718ade5af8285f71151eea824ce3cd">More...</a><br /></td></tr>
<tr class="separator:a8f718ade5af8285f71151eea824ce3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bbbd16324d70e859dea27feebed3f58"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_base_grid.html#a9bbbd16324d70e859dea27feebed3f58">getInfoExchangePartners</a> (std::set&lt; int &gt; &amp;psToSendTo, std::set&lt; int &gt; &amp;psToReceiveFrom)</td></tr>
<tr class="memdesc:a9bbbd16324d70e859dea27feebed3f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the set of processes with which this <a class="el" href="classrepast_1_1_projection.html" title="Abstract base class for all Projections. ">Projection</a> exchanges projection info.  <a href="#a9bbbd16324d70e859dea27feebed3f58">More...</a><br /></td></tr>
<tr class="separator:a9bbbd16324d70e859dea27feebed3f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77e5a4fba771e92b141f03f566b2a11"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_base_grid.html#ab77e5a4fba771e92b141f03f566b2a11">getAgentStatusExchangePartners</a> (std::set&lt; int &gt; &amp;psToSendTo, std::set&lt; int &gt; &amp;psToReceiveFrom)</td></tr>
<tr class="memdesc:ab77e5a4fba771e92b141f03f566b2a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the set of processes with which this <a class="el" href="classrepast_1_1_projection.html" title="Abstract base class for all Projections. ">Projection</a> exchanges agent status info- that is, the set of processes from which agents can move to this one or to which they can move when moving from this one.  <a href="#ab77e5a4fba771e92b141f03f566b2a11">More...</a><br /></td></tr>
<tr class="separator:ab77e5a4fba771e92b141f03f566b2a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classrepast_1_1_grid"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classrepast_1_1_grid')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classrepast_1_1_grid.html">repast::Grid&lt; T, GPType &gt;</a></td></tr>
<tr class="memitem:a0ee11fc5977ad4951f199cb90338c45f inherit pub_methods_classrepast_1_1_grid"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_grid.html#a0ee11fc5977ad4951f199cb90338c45f">Grid</a> (std::string <a class="el" href="classrepast_1_1_projection.html#ab60a0ab4f584685780307d7431b61800">name</a>)</td></tr>
<tr class="memdesc:a0ee11fc5977ad4951f199cb90338c45f inherit pub_methods_classrepast_1_1_grid"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classrepast_1_1_grid.html" title="Abstract interface for Grids and ContinuousSpaces. ">Grid</a> with the specified name.  <a href="#a0ee11fc5977ad4951f199cb90338c45f">More...</a><br /></td></tr>
<tr class="separator:a0ee11fc5977ad4951f199cb90338c45f inherit pub_methods_classrepast_1_1_grid"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe975f7aa1ba40dafaefebf67b118f9e inherit pub_methods_classrepast_1_1_grid"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe975f7aa1ba40dafaefebf67b118f9e"></a>
virtual const <a class="el" href="classrepast_1_1_grid_dimensions.html">GridDimensions</a>&#160;</td><td class="memItemRight" valign="bottom"><b>bounds</b> () const =0</td></tr>
<tr class="separator:afe975f7aa1ba40dafaefebf67b118f9e inherit pub_methods_classrepast_1_1_grid"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ff08ad641de4f74eab53e30ad14eb6 inherit pub_methods_classrepast_1_1_grid"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_grid.html#ab1ff08ad641de4f74eab53e30ad14eb6">getRequiredAgents</a> (std::set&lt; <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &gt; &amp;agentsToTest, std::set&lt; <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &gt; &amp;agentsRequired, RADIUS radius=<a class="el" href="classrepast_1_1_projection.html">Projection</a>&lt; T &gt;::PRIMARY)</td></tr>
<tr class="memdesc:ab1ff08ad641de4f74eab53e30ad14eb6 inherit pub_methods_classrepast_1_1_grid"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of agents to test, gets the subset that must be kept in order to fulfill the projection's 'contract' to the specified radius.  <a href="#ab1ff08ad641de4f74eab53e30ad14eb6">More...</a><br /></td></tr>
<tr class="separator:ab1ff08ad641de4f74eab53e30ad14eb6 inherit pub_methods_classrepast_1_1_grid"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46a5e7692430604bb3b04bbb9e2ff50 inherit pub_methods_classrepast_1_1_grid"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_grid.html#aa46a5e7692430604bb3b04bbb9e2ff50">keepsAgentsOnSyncProj</a> ()</td></tr>
<tr class="memdesc:aa46a5e7692430604bb3b04bbb9e2ff50 inherit pub_methods_classrepast_1_1_grid"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should return true if the <a class="el" href="classrepast_1_1_projection.html" title="Abstract base class for all Projections. ">Projection</a> implemented can 'keep' some (non-local) agents during a projection information synchronization operation.  <a href="#aa46a5e7692430604bb3b04bbb9e2ff50">More...</a><br /></td></tr>
<tr class="separator:aa46a5e7692430604bb3b04bbb9e2ff50 inherit pub_methods_classrepast_1_1_grid"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b7e2de573a9212a58a527a9ab519b8 inherit pub_methods_classrepast_1_1_grid"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_grid.html#ae3b7e2de573a9212a58a527a9ab519b8">sendsSecondaryAgentsOnStatusExchange</a> ()</td></tr>
<tr class="memdesc:ae3b7e2de573a9212a58a527a9ab519b8 inherit pub_methods_classrepast_1_1_grid"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should return true if the <a class="el" href="classrepast_1_1_projection.html" title="Abstract base class for all Projections. ">Projection</a> implemented will send secondary agents during a status exchange.  <a href="#ae3b7e2de573a9212a58a527a9ab519b8">More...</a><br /></td></tr>
<tr class="separator:ae3b7e2de573a9212a58a527a9ab519b8 inherit pub_methods_classrepast_1_1_grid"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b6d41862836606e0393df7558e4d20 inherit pub_methods_classrepast_1_1_grid"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4b6d41862836606e0393df7558e4d20"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>cleanProjectionInfo</b> (std::set&lt; <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &gt; &amp;agentsToKeep)</td></tr>
<tr class="separator:ae4b6d41862836606e0393df7558e4d20 inherit pub_methods_classrepast_1_1_grid"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classrepast_1_1_projection"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classrepast_1_1_projection')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classrepast_1_1_projection.html">repast::Projection&lt; T &gt;</a></td></tr>
<tr class="memitem:a2c5c9f33cf57c5e7a00402eab2080051 inherit pub_methods_classrepast_1_1_projection"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_projection.html#a2c5c9f33cf57c5e7a00402eab2080051">Projection</a> (std::string <a class="el" href="classrepast_1_1_projection.html#ab60a0ab4f584685780307d7431b61800">name</a>)</td></tr>
<tr class="memdesc:a2c5c9f33cf57c5e7a00402eab2080051 inherit pub_methods_classrepast_1_1_projection"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a projection with specified name.  <a href="#a2c5c9f33cf57c5e7a00402eab2080051">More...</a><br /></td></tr>
<tr class="separator:a2c5c9f33cf57c5e7a00402eab2080051 inherit pub_methods_classrepast_1_1_projection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab60a0ab4f584685780307d7431b61800 inherit pub_methods_classrepast_1_1_projection"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab60a0ab4f584685780307d7431b61800"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_projection.html#ab60a0ab4f584685780307d7431b61800">name</a> () const </td></tr>
<tr class="memdesc:ab60a0ab4f584685780307d7431b61800 inherit pub_methods_classrepast_1_1_projection"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name of this projection. <br /></td></tr>
<tr class="separator:ab60a0ab4f584685780307d7431b61800 inherit pub_methods_classrepast_1_1_projection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340bcbf86f1e29489b9ca1a4aa5e9298 inherit pub_methods_classrepast_1_1_projection"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_projection.html#a340bcbf86f1e29489b9ca1a4aa5e9298">addFilterVal</a> (int type)</td></tr>
<tr class="memdesc:a340bcbf86f1e29489b9ca1a4aa5e9298 inherit pub_methods_classrepast_1_1_projection"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an entry to the list of agent types that can be added to this projection.  <a href="#a340bcbf86f1e29489b9ca1a4aa5e9298">More...</a><br /></td></tr>
<tr class="separator:a340bcbf86f1e29489b9ca1a4aa5e9298 inherit pub_methods_classrepast_1_1_projection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4587f793b1c250de22af16fedf7f89d inherit pub_methods_classrepast_1_1_projection"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_projection.html#ab4587f793b1c250de22af16fedf7f89d">removeFilterVal</a> (int type)</td></tr>
<tr class="memdesc:ab4587f793b1c250de22af16fedf7f89d inherit pub_methods_classrepast_1_1_projection"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an entry from the list of agent types that can be added to this projection.  <a href="#ab4587f793b1c250de22af16fedf7f89d">More...</a><br /></td></tr>
<tr class="separator:ab4587f793b1c250de22af16fedf7f89d inherit pub_methods_classrepast_1_1_projection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35eae2c3351ef0de242a2ebeac8719df inherit pub_methods_classrepast_1_1_projection"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35eae2c3351ef0de242a2ebeac8719df"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_projection.html#a35eae2c3351ef0de242a2ebeac8719df">clearFilter</a> ()</td></tr>
<tr class="memdesc:a35eae2c3351ef0de242a2ebeac8719df inherit pub_methods_classrepast_1_1_projection"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the list of agent types that can be added to this projection; the result is that the filter is empty, and any agent can be added. <br /></td></tr>
<tr class="separator:a35eae2c3351ef0de242a2ebeac8719df inherit pub_methods_classrepast_1_1_projection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4075a777a46f27e978d376c90e74a409 inherit pub_methods_classrepast_1_1_projection"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_projection.html#a4075a777a46f27e978d376c90e74a409">agentCanBeAdded</a> (boost::shared_ptr&lt; T &gt; agent)</td></tr>
<tr class="memdesc:a4075a777a46f27e978d376c90e74a409 inherit pub_methods_classrepast_1_1_projection"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the agent can be added to the projection, which will be the case if the filter list is empty or if the agent's type is in the filter list.  <a href="#a4075a777a46f27e978d376c90e74a409">More...</a><br /></td></tr>
<tr class="separator:a4075a777a46f27e978d376c90e74a409 inherit pub_methods_classrepast_1_1_projection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66e268656f0baee2a7656d5eda6f4b9 inherit pub_methods_classrepast_1_1_projection"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae66e268656f0baee2a7656d5eda6f4b9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_projection.html#ae66e268656f0baee2a7656d5eda6f4b9">getProjectionInfo</a> (std::vector&lt; <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &gt; &amp;agents, std::vector&lt; <a class="el" href="classrepast_1_1_projection_info_packet.html">ProjectionInfoPacket</a> * &gt; &amp;packets, bool secondaryInfo=false, std::set&lt; <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &gt; *secondaryIds=0, int destProc=-1)</td></tr>
<tr class="memdesc:ae66e268656f0baee2a7656d5eda6f4b9 inherit pub_methods_classrepast_1_1_projection"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper that gets all of the projection information for the agents specified (calls implementation in child class that gets only the information for one agent). <br /></td></tr>
<tr class="separator:ae66e268656f0baee2a7656d5eda6f4b9 inherit pub_methods_classrepast_1_1_projection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89c14a3463d292ba1cd829204fbee71 inherit pub_methods_classrepast_1_1_projection"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae89c14a3463d292ba1cd829204fbee71"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_projection.html#ae89c14a3463d292ba1cd829204fbee71">updateProjectionInfo</a> (std::vector&lt; <a class="el" href="classrepast_1_1_projection_info_packet.html">ProjectionInfoPacket</a> * &gt; &amp;pips, <a class="el" href="classrepast_1_1_context.html">Context</a>&lt; T &gt; *context)</td></tr>
<tr class="memdesc:ae89c14a3463d292ba1cd829204fbee71 inherit pub_methods_classrepast_1_1_projection"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the projection information for the agents in this projection according to the information contained in the vector of information packets passed. <br /></td></tr>
<tr class="separator:ae89c14a3463d292ba1cd829204fbee71 inherit pub_methods_classrepast_1_1_projection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5cda203753da3d565d7839f92589e8 inherit pub_methods_classrepast_1_1_projection"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd5cda203753da3d565d7839f92589e8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>balance</b> ()</td></tr>
<tr class="separator:afd5cda203753da3d565d7839f92589e8 inherit pub_methods_classrepast_1_1_projection"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:acd798e07433e8da414ea2c9ce689f767"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd798e07433e8da414ea2c9ce689f767"></a>
typedef AgentLocationMap::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>LocationMapIter</b></td></tr>
<tr class="separator:acd798e07433e8da414ea2c9ce689f767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42588a88a435a0d3447c4752dd05b3ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42588a88a435a0d3447c4752dd05b3ff"></a>
typedef AgentLocationMap::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>LocationMapConstIter</b></td></tr>
<tr class="separator:a42588a88a435a0d3447c4752dd05b3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa119b75be38ed500437d908707752c53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa119b75be38ed500437d908707752c53"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>addAgent</b> (boost::shared_ptr&lt; T &gt; agent)</td></tr>
<tr class="separator:aa119b75be38ed500437d908707752c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a15e82c71ae8467e34adcef97eda10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3a15e82c71ae8467e34adcef97eda10"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>removeAgent</b> (T *agent)</td></tr>
<tr class="separator:ab3a15e82c71ae8467e34adcef97eda10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2895a0c0f8df474c70fe1f5dc9d7e79"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2895a0c0f8df474c70fe1f5dc9d7e79"></a>
LocationMapConstIter&#160;</td><td class="memItemRight" valign="bottom"><b>locationsBegin</b> () const </td></tr>
<tr class="separator:af2895a0c0f8df474c70fe1f5dc9d7e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e46f683b8f413cd4ef761791436d0c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e46f683b8f413cd4ef761791436d0c3"></a>
LocationMapConstIter&#160;</td><td class="memItemRight" valign="bottom"><b>locationsEnd</b> () const </td></tr>
<tr class="separator:a4e46f683b8f413cd4ef761791436d0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0d37e733a70b57f045f934ca9aa5f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab0d37e733a70b57f045f934ca9aa5f6"></a>
T *&#160;</td><td class="memItemRight" valign="bottom"><b>get</b> (const <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &amp;id)</td></tr>
<tr class="separator:aab0d37e733a70b57f045f934ca9aa5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a4116ebd80bf98c4d403bfdf1d7891b5e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4116ebd80bf98c4d403bfdf1d7891b5e"></a>
GPTransformer&#160;</td><td class="memItemRight" valign="bottom"><b>gpTransformer</b></td></tr>
<tr class="separator:a4116ebd80bf98c4d403bfdf1d7891b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268f1e662d2423eb06554c1da59f22c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a268f1e662d2423eb06554c1da59f22c2"></a>
Adder&#160;</td><td class="memItemRight" valign="bottom"><b>adder</b></td></tr>
<tr class="separator:a268f1e662d2423eb06554c1da59f22c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classrepast_1_1_projection"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classrepast_1_1_projection')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classrepast_1_1_projection.html">repast::Projection&lt; T &gt;</a></td></tr>
<tr class="memitem:a374d61a05feb62c25e2046170fbd2be4 inherit pro_attribs_classrepast_1_1_projection"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a374d61a05feb62c25e2046170fbd2be4"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>name_</b></td></tr>
<tr class="separator:a374d61a05feb62c25e2046170fbd2be4 inherit pro_attribs_classrepast_1_1_projection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2db74e98e56396c2a129a7aefeb19e inherit pro_attribs_classrepast_1_1_projection"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade2db74e98e56396c2a129a7aefeb19e"></a>
std::set&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>filter</b></td></tr>
<tr class="separator:ade2db74e98e56396c2a129a7aefeb19e inherit pro_attribs_classrepast_1_1_projection"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename CellAccessor, typename GPTransformer, typename Adder, typename GPType&gt;<br />
class repast::BaseGrid&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;</h3>

<p>Base grid implementation, implementing elements common to both Grids and ContinuousSpaces. </p>
<p>Standard grid and space types that provide defaults for the various template parameters can be found in Space in Space.h</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of objects contained by this <a class="el" href="classrepast_1_1_base_grid.html" title="Base grid implementation, implementing elements common to both Grids and ContinuousSpaces. ">BaseGrid</a> (generally the type of agents) </td></tr>
    <tr><td class="paramname">CellAccessor</td><td>implements the actual storage for the grid. </td></tr>
    <tr><td class="paramname">GPTransformer</td><td>transforms cell points according to the topology (e.g. periodic) of the <a class="el" href="classrepast_1_1_base_grid.html" title="Base grid implementation, implementing elements common to both Grids and ContinuousSpaces. ">BaseGrid</a>. </td></tr>
    <tr><td class="paramname">Adder</td><td>determines how objects are added to the grid from its associated context. </td></tr>
    <tr><td class="paramname">GPType</td><td>the coordinate type of the grid point locations; this must be an int or a double. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a73eae15ca682e2c03a71392c29453d43"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename CellAccessor , typename GPTransformer , typename Adder , typename GPType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrepast_1_1_base_grid.html">repast::BaseGrid</a>&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;::<a class="el" href="classrepast_1_1_base_grid.html">BaseGrid</a> </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrepast_1_1_grid_dimensions.html">GridDimensions</a>&#160;</td>
          <td class="paramname"><em>dimensions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classrepast_1_1_base_grid.html" title="Base grid implementation, implementing elements common to both Grids and ContinuousSpaces. ">BaseGrid</a> with the specified name and dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the <a class="el" href="classrepast_1_1_base_grid.html" title="Base grid implementation, implementing elements common to both Grids and ContinuousSpaces. ">BaseGrid</a> </td></tr>
    <tr><td class="paramname">dimensions</td><td>the dimensions of the <a class="el" href="classrepast_1_1_base_grid.html" title="Base grid implementation, implementing elements common to both Grids and ContinuousSpaces. ">BaseGrid</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ab5aa5a65509879b528bac5b3a9f544b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename CellAccessor, typename GPTransformer, typename Adder, typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classrepast_1_1_base_grid.html#ae4de9c96ae3ee3d7021a1e5b3c61b9a6">const_iterator</a> <a class="el" href="classrepast_1_1_base_grid.html">repast::BaseGrid</a>&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an iterator over the agents in this <a class="el" href="classrepast_1_1_base_grid.html" title="Base grid implementation, implementing elements common to both Grids and ContinuousSpaces. ">BaseGrid</a> starting with the first agent. </p>
<p>The iterator derefrences into shared_ptr&lt;T&gt;. The actual agent can be accessed by derefrenceing the iter: (*iter)-&gt;getId() for example.</p>
<dl class="section return"><dt>Returns</dt><dd>an iterator over the agents in this <a class="el" href="classrepast_1_1_base_grid.html" title="Base grid implementation, implementing elements common to both Grids and ContinuousSpaces. ">BaseGrid</a> starting with the first agent. </dd></dl>

</div>
</div>
<a class="anchor" id="a648fcba07fdc15b4072b5807b4f1b6b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename CellAccessor , typename GPTransformer , typename Adder , typename GPType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classrepast_1_1_base_grid.html">repast::BaseGrid</a>&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether or not this grid contains the agent with the specified id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the id of the agent to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the grid contains the agent, otherwise false. </dd></dl>

<p>Implements <a class="el" href="classrepast_1_1_grid.html#a022599f875eeb1e72c11766500d8282c">repast::Grid&lt; T, GPType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a5f8a2fc16b8aeba026a58fcb374cf05c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename CellAccessor, typename GPTransformer, typename Adder, typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classrepast_1_1_grid_dimensions.html">GridDimensions</a> <a class="el" href="classrepast_1_1_base_grid.html">repast::BaseGrid</a>&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;::dimensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the dimensions of this <a class="el" href="classrepast_1_1_grid.html" title="Abstract interface for Grids and ContinuousSpaces. ">Grid</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the dimensions of this <a class="el" href="classrepast_1_1_grid.html" title="Abstract interface for Grids and ContinuousSpaces. ">Grid</a>. </dd></dl>

<p>Implements <a class="el" href="classrepast_1_1_grid.html#ac6a979a6491565212ae44b8bfbbc9393">repast::Grid&lt; T, GPType &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classrepast_1_1_shared_base_grid.html#a9ec19652232000368ec1fe98ff47e121">repast::SharedBaseGrid&lt; T, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_shared_base_grid.html#a9ec19652232000368ec1fe98ff47e121">repast::SharedBaseGrid&lt; RelogoAgent, GPTransformer, Adder, int &gt;</a>, <a class="el" href="classrepast_1_1_shared_base_grid.html#a9ec19652232000368ec1fe98ff47e121">repast::SharedBaseGrid&lt; T, GPTransformer, Adder, int &gt;</a>, <a class="el" href="classrepast_1_1_shared_base_grid.html#a9ec19652232000368ec1fe98ff47e121">repast::SharedBaseGrid&lt; T, GPTransformer, Adder, double &gt;</a>, and <a class="el" href="classrepast_1_1_shared_base_grid.html#a9ec19652232000368ec1fe98ff47e121">repast::SharedBaseGrid&lt; RelogoAgent, GPTransformer, Adder, double &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ac7eced6c979ccf417b4bbc1c064c687d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename CellAccessor, typename GPTransformer, typename Adder, typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classrepast_1_1_base_grid.html#ae4de9c96ae3ee3d7021a1e5b3c61b9a6">const_iterator</a> <a class="el" href="classrepast_1_1_base_grid.html">repast::BaseGrid</a>&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the end of an iterator over the agents in this <a class="el" href="classrepast_1_1_base_grid.html" title="Base grid implementation, implementing elements common to both Grids and ContinuousSpaces. ">BaseGrid</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the end of an iterator over the agents in this <a class="el" href="classrepast_1_1_base_grid.html" title="Base grid implementation, implementing elements common to both Grids and ContinuousSpaces. ">BaseGrid</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ab77e5a4fba771e92b141f03f566b2a11"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename CellAccessor, typename GPTransformer, typename Adder, typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classrepast_1_1_base_grid.html">repast::BaseGrid</a>&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;::getAgentStatusExchangePartners </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>psToSendTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>psToReceiveFrom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the set of processes with which this <a class="el" href="classrepast_1_1_projection.html" title="Abstract base class for all Projections. ">Projection</a> exchanges agent status info- that is, the set of processes from which agents can move to this one or to which they can move when moving from this one. </p>
<p>In the most general case this will be all other processors. However, simulations where agents move in spaces will usually exchange agents only with a small subset of 'neighbor' processes, which is knowable in advance and constant. To accommodate the general case, the algorithm for exchanging information must poll all other processes to see which are sending to this one; if this is known in advance, this additional (expensive) step can be skipped. </p>

<p>Implements <a class="el" href="classrepast_1_1_grid.html#a748354698308fe0d0c0fe33a657109d1">repast::Grid&lt; T, GPType &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classrepast_1_1_shared_base_grid.html#a0388d98240eb59548058d3c45da702d7">repast::SharedBaseGrid&lt; T, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_shared_base_grid.html#a0388d98240eb59548058d3c45da702d7">repast::SharedBaseGrid&lt; RelogoAgent, GPTransformer, Adder, int &gt;</a>, <a class="el" href="classrepast_1_1_shared_base_grid.html#a0388d98240eb59548058d3c45da702d7">repast::SharedBaseGrid&lt; T, GPTransformer, Adder, int &gt;</a>, <a class="el" href="classrepast_1_1_shared_base_grid.html#a0388d98240eb59548058d3c45da702d7">repast::SharedBaseGrid&lt; T, GPTransformer, Adder, double &gt;</a>, and <a class="el" href="classrepast_1_1_shared_base_grid.html#a0388d98240eb59548058d3c45da702d7">repast::SharedBaseGrid&lt; RelogoAgent, GPTransformer, Adder, double &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a8f718ade5af8285f71151eea824ce3cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename CellAccessor, typename GPTransformer, typename Adder, typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classrepast_1_1_base_grid.html">repast::BaseGrid</a>&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;::getAgentsToPush </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>agentsToTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; int, std::set&lt; <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>agentsToPush</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a set of agents, gets the agents that this projection implementation must 'push' to other processes. </p>
<p>Generally spaces must push agents that are in 'buffer zones' and graphs must push local agents that are vertices to master edges where the other vertex is non- local. The results are returned per-process in the agentsToPush map. </p>

<p>Implements <a class="el" href="classrepast_1_1_grid.html#aa83b294fc8765e2f8ee44d8238855460">repast::Grid&lt; T, GPType &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classrepast_1_1_shared_base_grid.html#ab1486e7698288efc1218653d4e5e1e15">repast::SharedBaseGrid&lt; T, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_shared_base_grid.html#ab1486e7698288efc1218653d4e5e1e15">repast::SharedBaseGrid&lt; RelogoAgent, GPTransformer, Adder, int &gt;</a>, <a class="el" href="classrepast_1_1_shared_base_grid.html#ab1486e7698288efc1218653d4e5e1e15">repast::SharedBaseGrid&lt; T, GPTransformer, Adder, int &gt;</a>, <a class="el" href="classrepast_1_1_shared_base_grid.html#ab1486e7698288efc1218653d4e5e1e15">repast::SharedBaseGrid&lt; T, GPTransformer, Adder, double &gt;</a>, and <a class="el" href="classrepast_1_1_shared_base_grid.html#ab1486e7698288efc1218653d4e5e1e15">repast::SharedBaseGrid&lt; RelogoAgent, GPTransformer, Adder, double &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a8c3b8755d2fc2bf75163a0fc76ce1d4a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename CellAccessor , typename GPTransformer , typename Adder , typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrepast_1_1_base_grid.html">repast::BaseGrid</a>&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;::getDisplacement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; GPType &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets vector difference between point 1 and point 2, putting the result in out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">p1</td><td>the first point </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">p2</td><td>the second point </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">the</td><td>vector where the difference will be put </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classrepast_1_1_grid.html#a23236c2387ba343121dbf71901dbb341">repast::Grid&lt; T, GPType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a124b5f53a5e96e9ed8e59534e9417f42"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename CellAccessor , typename GPTransformer , typename Adder , typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classrepast_1_1_base_grid.html">repast::BaseGrid</a>&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;::getDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the distance between the two grid points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>the first point </td></tr>
    <tr><td class="paramname">p2</td><td>the second point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the distance between pt1 and pt2. </dd></dl>

<p>Implements <a class="el" href="classrepast_1_1_grid.html#a27213b5f9decf10e1c99a5a7b4ae387a">repast::Grid&lt; T, GPType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a8075dd20e6d559d453a530943ab9d387"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename CellAccessor , typename GPTransformer , typename Adder , typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classrepast_1_1_base_grid.html">repast::BaseGrid</a>&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;::getDistanceSq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the square of the distance between the two grid points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>the first point </td></tr>
    <tr><td class="paramname">p2</td><td>the second point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the square of the distance between pt1 and pt2. </dd></dl>

<p>Implements <a class="el" href="classrepast_1_1_grid.html#a456d00d28995a48b41b8f6c84817879e">repast::Grid&lt; T, GPType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a9bbbd16324d70e859dea27feebed3f58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename CellAccessor, typename GPTransformer, typename Adder, typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classrepast_1_1_base_grid.html">repast::BaseGrid</a>&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;::getInfoExchangePartners </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>psToSendTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>psToReceiveFrom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the set of processes with which this <a class="el" href="classrepast_1_1_projection.html" title="Abstract base class for all Projections. ">Projection</a> exchanges projection info. </p>
<p>In the most general case this will be all other processors; this is the case for graphs, where agent connections can be arbitrary. However, spaces usually exchange information only with a small subset of 'neighbor' processes, which is knowable in advance and constant. To accommodate the general case, the algorithm for exchanging information must poll all other processes to see which are sending to this one; if this is known in advance, this additional (expensive) step can be skipped. </p>

<p>Implements <a class="el" href="classrepast_1_1_grid.html#a57b4449e602392119eb4db3e0011de05">repast::Grid&lt; T, GPType &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classrepast_1_1_shared_base_grid.html#af4323686714c4f6216125db5609c3184">repast::SharedBaseGrid&lt; T, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_shared_base_grid.html#af4323686714c4f6216125db5609c3184">repast::SharedBaseGrid&lt; RelogoAgent, GPTransformer, Adder, int &gt;</a>, <a class="el" href="classrepast_1_1_shared_base_grid.html#af4323686714c4f6216125db5609c3184">repast::SharedBaseGrid&lt; T, GPTransformer, Adder, int &gt;</a>, <a class="el" href="classrepast_1_1_shared_base_grid.html#af4323686714c4f6216125db5609c3184">repast::SharedBaseGrid&lt; T, GPTransformer, Adder, double &gt;</a>, and <a class="el" href="classrepast_1_1_shared_base_grid.html#af4323686714c4f6216125db5609c3184">repast::SharedBaseGrid&lt; RelogoAgent, GPTransformer, Adder, double &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a9ef8aae56bb771fa152b10408d718f6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename CellAccessor , typename GPTransformer , typename Adder , typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classrepast_1_1_base_grid.html">repast::BaseGrid</a>&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;::getLocation </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>agent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; GPType &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the location of this agent and puts it in the specified vector. </p>
<p>The x coordinate will be the first value, the y the second and so on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">agent</td><td>the agent whose location we want to get </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">the</td><td>vector where the agents location will be put</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the location was successfully found, otherwise false. </dd></dl>

<p>Implements <a class="el" href="classrepast_1_1_grid.html#a159a33da91ef58dbd8ca88829d82ca36">repast::Grid&lt; T, GPType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aa18b424b73ff46fde970ad1e1bb3cdc4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename CellAccessor , typename GPTransformer , typename Adder , typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classrepast_1_1_base_grid.html">repast::BaseGrid</a>&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;::getLocation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; GPType &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the location of this agent and puts it in the specified vectors. </p>
<p>The x coordinate will be the first value, the y the second and so on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">id</td><td>the id of the agent whose location we want to get </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>the agent's location will be put into this vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the location was successfully found, otherwise false. </dd></dl>

<p>Implements <a class="el" href="classrepast_1_1_grid.html#a6fef590f66b69e4a06207df59d1b2737">repast::Grid&lt; T, GPType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a3710f4aca96eeb3a95a44fe80e0c998a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename CellAccessor , typename GPTransformer , typename Adder , typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classrepast_1_1_base_grid.html">repast::BaseGrid</a>&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;::getObjectAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the first object found at the specified point, or NULL if there is no such object. </p>
<dl class="section return"><dt>Returns</dt><dd>the first object found at the specified point, or NULL if there is no such object. </dd></dl>

<p>Implements <a class="el" href="classrepast_1_1_grid.html#a8b77b072353aed6f06b6d02e21ee9879">repast::Grid&lt; T, GPType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a21d840f3eb758b8f223ca51bf1996328"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename CellAccessor , typename GPTransformer , typename Adder , typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrepast_1_1_base_grid.html">repast::BaseGrid</a>&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;::getObjectsAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets all the objects found at the specified point. </p>
<p>The found objects will be put into the out parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pt</td><td>the point to get all the objects at </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>the vector into which the found objects will be put </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classrepast_1_1_grid.html#aaa3a1fd92707079f7dd4805e36ca83ff">repast::Grid&lt; T, GPType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a4dd5ec33acc952ab136f5e2b9886771e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename CellAccessor, typename GPTransformer, typename Adder, typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classrepast_1_1_base_grid.html">repast::BaseGrid</a>&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;::isPeriodic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether or not this grid is periodic (i.e. </p>
<p>toroidal).</p>
<dl class="section return"><dt>Returns</dt><dd>true if this <a class="el" href="classrepast_1_1_grid.html" title="Abstract interface for Grids and ContinuousSpaces. ">Grid</a> is periodic, otherwise false. </dd></dl>

<p>Implements <a class="el" href="classrepast_1_1_grid.html#a81e7eb612dabbf2fb4b3f1190cd92f88">repast::Grid&lt; T, GPType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a75758e9f795679c0a9c9b92fbd9413af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename CellAccessor , typename GPTransformer , typename Adder , typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; bool, <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &gt; <a class="el" href="classrepast_1_1_base_grid.html">repast::BaseGrid</a>&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;::moveByDisplacement </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>agent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; GPType &gt; &amp;&#160;</td>
          <td class="paramname"><em>displacement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the specified object from its current location by the specified amount. </p>
<p>For example <code>moveByDisplacement(object, 3, -2, 1)</code> will move the object by 3 along the x-axis, -2 along the y and 1 along the z. The displacement argument can be less than the number of dimensions in the space in which case the remaining argument will be set to 0. For example, <code>moveByDisplacement(object, 3)</code> will move the object 3 along the x-axis and 0 along the y and z axes, assuming a 3D grid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">agent</td><td>the object to move </td></tr>
    <tr><td class="paramname">displacement</td><td>the amount to move the object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair containing a bool that indicates whether the move was a success or not, and the point where the agent was moved to. </dd></dl>

<p>Implements <a class="el" href="classrepast_1_1_grid.html#a20efd6bdadf8dac405542de7e33f6b9e">repast::Grid&lt; T, GPType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a40e9d1d23b2e9f4e3d40d87d92595693"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename CellAccessor , typename GPTransformer , typename Adder , typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classrepast_1_1_base_grid.html">repast::BaseGrid</a>&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;::moveTo </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>agent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; GPType &gt; &amp;&#160;</td>
          <td class="paramname"><em>newLocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the specified agent to the specified location. </p>
<p>Returns true if the move was successful otherwise false. The agent must be already added to the context associated with this space, otherwise this throws an out_of_range exception if the new location out of bounds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">agent</td><td>the agent to move </td></tr>
    <tr><td class="paramname">newLocation</td><td>the location to move to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the move was successful, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="a60f5499f55a0736c07ed87bb37caeae8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename CellAccessor , typename GPTransformer , typename Adder , typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classrepast_1_1_base_grid.html">repast::BaseGrid</a>&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;::moveTo </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>agent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;&#160;</td>
          <td class="paramname"><em>newLocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the specified agent to the specified location. </p>
<p>Returns true if the move was successful otherwise false. The agent must be already added to the context associated with this space, otherwise this throws an out_of_range exception if the new location out of bounds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">agent</td><td>the agent to move </td></tr>
    <tr><td class="paramname">newLocation</td><td>the location to move to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the move was successful, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="a3a39996218f4426aa1b2f081d3b44eb4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename CellAccessor , typename GPTransformer , typename Adder , typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classrepast_1_1_base_grid.html">repast::BaseGrid</a>&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;::moveTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; GPType &gt; &amp;&#160;</td>
          <td class="paramname"><em>newLocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the specified agent to the specified location. </p>
<p>Returns true if the move was successful otherwise false. The agent must be already added to the context associated with this space, otherwise this throws an out_of_range exception if the new location out of bounds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the id of the agent to move </td></tr>
    <tr><td class="paramname">newLocation</td><td>the location to move to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the move was successful, otherwise false </dd></dl>

<p>Reimplemented in <a class="el" href="classrepast_1_1_shared_base_grid.html#a480fc6f517d1bb098c7ee47450fba522">repast::SharedBaseGrid&lt; T, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_shared_base_grid.html#a480fc6f517d1bb098c7ee47450fba522">repast::SharedBaseGrid&lt; RelogoAgent, GPTransformer, Adder, int &gt;</a>, <a class="el" href="classrepast_1_1_shared_base_grid.html#a480fc6f517d1bb098c7ee47450fba522">repast::SharedBaseGrid&lt; T, GPTransformer, Adder, int &gt;</a>, <a class="el" href="classrepast_1_1_shared_base_grid.html#a480fc6f517d1bb098c7ee47450fba522">repast::SharedBaseGrid&lt; T, GPTransformer, Adder, double &gt;</a>, and <a class="el" href="classrepast_1_1_shared_base_grid.html#a480fc6f517d1bb098c7ee47450fba522">repast::SharedBaseGrid&lt; RelogoAgent, GPTransformer, Adder, double &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a9f3dbdfe875327dbcc069971de98bc83"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename CellAccessor , typename GPTransformer , typename Adder , typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classrepast_1_1_base_grid.html">repast::BaseGrid</a>&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;::moveTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the specified agent to the specified point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the id of the agent to move </td></tr>
    <tr><td class="paramname">pt</td><td>where to move the agent to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the move was successful, otherwise false </dd></dl>

<p>Implements <a class="el" href="classrepast_1_1_grid.html#ae5bf061d62f1998e0c75bf3967ac63d3">repast::Grid&lt; T, GPType &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classrepast_1_1_shared_base_grid.html#ab4d74c36e126cffa5638aeaab6c0df85">repast::SharedBaseGrid&lt; T, GPTransformer, Adder, GPType &gt;</a>, <a class="el" href="classrepast_1_1_shared_base_grid.html#ab4d74c36e126cffa5638aeaab6c0df85">repast::SharedBaseGrid&lt; RelogoAgent, GPTransformer, Adder, int &gt;</a>, <a class="el" href="classrepast_1_1_shared_base_grid.html#ab4d74c36e126cffa5638aeaab6c0df85">repast::SharedBaseGrid&lt; T, GPTransformer, Adder, int &gt;</a>, <a class="el" href="classrepast_1_1_shared_base_grid.html#ab4d74c36e126cffa5638aeaab6c0df85">repast::SharedBaseGrid&lt; T, GPTransformer, Adder, double &gt;</a>, and <a class="el" href="classrepast_1_1_shared_base_grid.html#ab4d74c36e126cffa5638aeaab6c0df85">repast::SharedBaseGrid&lt; RelogoAgent, GPTransformer, Adder, double &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ab1e81ffc9b8f581279a89abf1a4e62e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename CellAccessor, typename GPTransformer, typename Adder, typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="classrepast_1_1_base_grid.html">repast::BaseGrid</a>&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of agents in this <a class="el" href="classrepast_1_1_base_grid.html" title="Base grid implementation, implementing elements common to both Grids and ContinuousSpaces. ">BaseGrid</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of agents in this <a class="el" href="classrepast_1_1_base_grid.html" title="Base grid implementation, implementing elements common to both Grids and ContinuousSpaces. ">BaseGrid</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="abe3c51f54b40e50e5e2b92b0b1b8e0de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename CellAccessor, typename GPTransformer, typename Adder, typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classrepast_1_1_base_grid.html">repast::BaseGrid</a>&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; GPType &gt; &amp;&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; GPType &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms the specified location using the properties (e.g. </p>
<p>toroidal) of this space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">location</td><td>the location to transform </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>the vector where the result of the transform will be put </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classrepast_1_1_grid.html#a001bf75cd2e436112555a5f992d1d372">repast::Grid&lt; T, GPType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aa5607ff3f29ed7478f0de1d6884e0d7e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename CellAccessor, typename GPTransformer, typename Adder, typename GPType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classrepast_1_1_base_grid.html">repast::BaseGrid</a>&lt; T, CellAccessor, GPTransformer, Adder, GPType &gt;::translate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrepast_1_1_point.html">Point</a>&lt; GPType &gt; &amp;&#160;</td>
          <td class="paramname"><em>displacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; GPType &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translates the specified location by the specified displacement put the result in out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">location</td><td>the initial location </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">displacement</td><td>the amount to translate the location by </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>the vector where the result of the translation is put </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classrepast_1_1_grid.html#a5aa30c315b9a32830b804d2e49af14d0">repast::Grid&lt; T, GPType &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/nick/Documents/repos/repast-hpc/src/repast_hpc/<a class="el" href="_base_grid_8h_source.html">BaseGrid.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Sep 28 2016 11:11:31 for RepastHPC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
