<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.9" />
<title>Repast Simphony Documentation</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


@media screen {
  body {
    max-width: 50em; /* approximately 80 characters wide */
    margin-left: 16em;
  }

  #toc {
    position: fixed;
    top: 0;
    left: 0;
    bottom: 0;
    width: 13em;
    padding: 0.5em;
    padding-bottom: 1.5em;
    margin: 0;
    overflow: auto;
    border-right: 3px solid #f8f8f8;
    background-color: white;
  }

  #toc .toclevel1 {
    margin-top: 0.5em;
  }

  #toc .toclevel2 {
    margin-top: 0.25em;
    display: list-item;
    color: #aaaaaa;
  }

  #toctitle {
    margin-top: 0.5em;
  }
}
</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install(2);
/*]]>*/
</script>
</head>
<body class="article" style="max-width:55em">
<div id="header">
<h1>Repast Simphony Documentation</h1>
<span id="author">Version 2.5 October 2017</span><br />
<div id="toc">
  <div id="toctitle">Table of Contents</div>
  <noscript><p><b>JavaScript must be enabled in your browser to display the table of contents.</b></p></noscript>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_introduction">1. Introduction</h2>
<div class="sectionbody">
<div class="paragraph"><p>Repast Simphony is a tightly integrated, richly interactive, cross platform
Java-based modeling system that runs under Microsoft Windows, Apple macOS,
and Linux. Repast supports the development of extremely flexible models of
interacting agents for use on workstations and computing clusters. Repast
Simphony models can be developed in several different forms including the ReLogo
dialect of Logo, point-and-click statecharts, Groovy, or Java, all of which can
be fluidly interleaved.</p></div>
<div class="paragraph"><p>This "cookbook style" reference manual provides background and code examples for
many aspects of the Repast Simphony API but does not show how to build a
complete working model from scratch. It is recommended that new users first
review the introductory tutorial documents included with the Repast installer
and available at the Repast online documentation page:
<a href="https://repast.github.io/docs.html">https://repast.github.io/docs.html</a></p></div>
<div class="sect2">
<h3 id="_support">1.1. Support</h3>
<div class="paragraph"><p>The primary means of obtaining help with Repast is the
<a href="http://lists.sourceforge.net/lists/listinfo/repast-interest">Repast Interest</a>
mailing list and the accumulated
<a href="https://sourceforge.net/p/repast/mailman/repast-interest">list archives</a>.
To post a technical question about any  edition of Repast to all of the list
members, please send an email message to <a href="mailto:repast-interest@lists.sourceforge.net">repast-interest@lists.sourceforge.net</a>.
(Due to spam, the repast-interest list now limits postings to subscribed users.
While questions are welcome and usually answered quickly, please check
the list archives before sending a message as your question may already have
been answered.</p></div>
<div class="paragraph"><p>For those interested in regularly hearing about Repast and learning from other&#8217;s
technical questions, please consider subscribing to the Repast Interest mailing
list.</p></div>
</div>
<div class="sect2">
<h3 id="_installation">1.2. Installation</h3>
<div class="paragraph"><p>Current software releases are available from
<a href="https://github.com/Repast/repast.simphony/releases/">https://github.com/Repast/repast.simphony/releases/</a>.</p></div>
<div class="paragraph"><div class="title">Microsoft Windows</div><p><a href="https://www.java.com">Java</a> must be installed prior to running Repast Simphony.
We reccommend using both the 64-bit version of Java and Repast, which is
available as a 32-bit or 64-bit installer for Windows.  If you have 32-bit Java
installed you must use the 32-bit Repast installer, and likewise if you have the
64-bit version of Java installed, you must use the 64-bit Repast installer.</p></div>
<div class="paragraph"><div class="title">macOS</div><p>macOS users should download the macOS X Disk Image, double click on the
resulting file and follow the installation instructions that appear. You may
need to alter your Security &amp; Privacy settings in System Preferences to allow
you to open Repast Simphony. Alternatively, right clicking on the Repast
Simphony application and selecting Open will allow you to authenticate and open
it.</p></div>
<div class="paragraph"><div class="title">Linux</div><p>Linux users and Unix-related system users should download
<a href="http://www.eclipse.org/downloads/packages/eclipse-ide-eclipse-committers/oxygen1">
Eclipse IDE for Eclipse Committers Oxygen</a> then use the Eclipse Update Manager
(under Help &#8594; Install New Software) to install Repast from its update site:
<a href="https://repocafe.cels.anl.gov/repos/repast/">https://repocafe.cels.anl.gov/repos/repast/</a>. Repast when installed via the
update site has the following additional requirement that can be installed using
Eclipse&#8217;s Update Manager.</p></div>
<div class="paragraph"><p>From the Groovy Update Site (<a href="http://dist.springsource.org/snapshot/GRECLIPSE/e4.7/">http://dist.springsource.org/snapshot/GRECLIPSE/e4.7/</a>):</p></div>
<div class="ulist"><ul>
<li>
<p>
Extra Groovy Compilers
</p>
</li>
<li>
<p>
Groovy-Eclipse
</p>
</li>
<li>
<p>
Uncategorized
</p>
</li>
</ul></div>
<div class="paragraph"><p>Once you have downloaded eclipse and installed the plugins, the groovy compiler
version must be set to anything in the 2.0. version line. Anything else will
prevent Repast Simphony and especially ReLogo from working correctly. You can
set the groovy compiler preferences in either the workspace or project
preferences pane via the "Groovy Compiler" page.</p></div>
<div class="paragraph"><p>The demonstration models are not provided via the update site, but they can be
downloaded from the GitHub repository:
<a href="https://github.com/Repast/repast.simphony.models/">https://github.com/Repast/repast.simphony.models/</a>. Once downloaded, start
Eclipse and switch to your chosen workspace. Right click in the package panel,
and choose import, General, Archive File and follow the wizard from there.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_project_configuration">2. Project Configuration</h2>
<div class="sectionbody">
<div class="paragraph"><p>If you have an existing Java project in which you would like to reference Repast
classes, you can right click on the project and select Repast Simphony &#8594; Add
Repast Simphony to this Project. This will add the Repast libraries to the
project class path so that you can reference Repast classes and run simulations
from your project without needing to manually add all of the Repast libraries
and dependencies.</p></div>
<div class="sect2">
<h3 id="_model_configuration_files">2.1. Model Configuration Files</h3>
<div class="listingblock">
<div class="title">user_path.xml</div>
<div class="content">
<pre><code>&lt;model name="Model Name"&gt;
        &lt;classpath&gt;
                &lt;entry path="..." annotations="[true|false]" /&gt;
                &lt;agents path="..." filter="..." /&gt;
                &lt;builtin fullname="..." /&gt;
        &lt;/classpath&gt;
&lt;/model&gt;</code></pre>
</div></div>
<div class="ulist"><ul>
<li>
<p>
path is path statement to a directory or jar file. If the directory contains
jars then all those jars are added to the classpath. If the directory or its
children contain .class files then the directory is added to the classpath. More
than one path can be specified. Multiple paths should be "," separated. For .class
files, the path functions as a classpath and so it must be the directory
immediately above the directories corresponding to the class packages. For
example, given the class repast.simphony.MyClass and the directory structure
X/bin/repast/simphony/MyClass.class, the path should be X/bin. This applies to
path in both entry and agents elements.
</p>
</li>
<li>
<p>
annotations specified whether or not any classes found in the specified
path(s) should be processed for annotations. The default is false.
</p>
</li>
<li>
<p>
agents specifies the path where agent classes can be found. These are
automatically processed for annotations.
</p>
</li>
<li>
<p>
filter specifies a class filter on the agents path(s). For example a filter
of "anl.gov.Agent" will filter out all classes but anl.gov.Agent as agent
classes. Filters can contain the wildcard "*". So for example, "anl.gov.*Agent"
will include any class in the package anl.gov whose class name ends with Agent.
</p>
</li>
<li>
<p>
the builtin element is for the case when a user needs to add an agent class
existing in one of the repast plugins. The user specifies the canonical class
name as the fullname.
</p>
</li>
</ul></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/note.png" alt="Note" />
</td>
<td class="content">For the builtins, since the class can be in any one of the repast plugins,
without hard coding the path, it is difficult to use the filter mechanism on all
the plugins. This means that unless we can figure out a way to figure out the
path of a resource containing a package, we must specify each individual class
that we&#8217;d like to be considered an agent class. The good news is that this is
not a common usage.</td>
</tr></table>
</div>
<div class="paragraph"><div class="title">context.xml</div><p>context.xml contains the context heirarchy information.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;context id="..." class="..."&gt;
        &lt;attribute id="..." value="..." type="[int|long|double|float|boolean|string|...]"
                display_name="..." converter="..."/&gt;

        &lt;projection id="..." type="[network|grid|continuous space|geography|value layer]"&gt;
                &lt;attribute id="..." .../&gt;
        &lt;/projection&gt;

        &lt;context id="..." class="..."&gt;
                ...
        &lt;/context&gt;
&lt;/context&gt;</code></pre>
</div></div>
<div class="tableblock">
<table rules="all"
width="60%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 1. Context Element</caption>
<col width="33%" />
<col width="33%" />
<col width="33%" />
<thead>
<tr>
<th align="left" valign="top">Attribute Name </th>
<th align="left" valign="top">Description </th>
<th align="left" valign="top">Required</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">id</p></td>
<td align="left" valign="top"><p class="table">Unique identifer for the context</p></td>
<td align="left" valign="top"><p class="table">YES</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">class</p></td>
<td align="left" valign="top"><p class="table">Fully qualitifed name of a Context implementation. If this
is present this context will be used instead of the default</p></td>
<td align="left" valign="top"><p class="table">NO</p></td>
</tr>
</tbody>
</table>
</div>
<div class="tableblock">
<table rules="all"
width="60%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 2. Attribute Element</caption>
<col width="33%" />
<col width="33%" />
<col width="33%" />
<thead>
<tr>
<th align="left" valign="top">Attribute Name </th>
<th align="left" valign="top">Description </th>
<th align="left" valign="top">Required</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">id</p></td>
<td align="left" valign="top"><p class="table">Unique identifer for the attribute</p></td>
<td align="left" valign="top"><p class="table">YES</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">value</p></td>
<td align="left" valign="top"><p class="table">Default value of the attribute</p></td>
<td align="left" valign="top"><p class="table">YES</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">type</p></td>
<td align="left" valign="top"><p class="table">The primitive or class type of the attribute</p></td>
<td align="left" valign="top"><p class="table">YES</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">display_name</p></td>
<td align="left" valign="top"><p class="table">Optional name used to display the attribute when it is used as a
model parameter</p></td>
<td align="left" valign="top"><p class="table">NO</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">converter</p></td>
<td align="left" valign="top"><p class="table">Optional implementation of StringConverter used
to convert the attribute to and from a string representation</p></td>
<td align="left" valign="top"><p class="table">NO</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>For example:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;context id="MyContext"&gt;
        &lt;attribute id="numAgents" value="20" type="int" display_name="Initial Number of Agents"/&gt;
&lt;/context&gt;</code></pre>
</div></div>
<div class="tableblock">
<table rules="all"
width="60%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 3. Projection Element</caption>
<col width="33%" />
<col width="33%" />
<col width="33%" />
<thead>
<tr>
<th align="left" valign="top">Attribute Name </th>
<th align="left" valign="top">Description </th>
<th align="left" valign="top">Required</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">id</p></td>
<td align="left" valign="top"><p class="table">Unique identifer for the projection</p></td>
<td align="left" valign="top"><p class="table">YES</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">type</p></td>
<td align="left" valign="top"><p class="table">The projection type (network, grid, geography, continuous space, value layer)</p></td>
<td align="left" valign="top"><p class="table">YES</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><div class="title">Special Attributes</div><p>If certain special attributes are present, then the context.xml file can be used
to instantiate the actual context hierarchy. The attributes are defined in the repast.simphony.dataLoader.engine.AutoBuilderConstants.</p></div>
<div class="tableblock">
<table rules="all"
width="60%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 4. Context Attributes</caption>
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
<thead>
<tr>
<th align="left" valign="top">Attribute Id </th>
<th align="left" valign="top">Description </th>
<th align="left" valign="top">Allowed values </th>
<th align="left" valign="top">type </th>
<th align="left" valign="top">Required</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">_timeUnits_</p></td>
<td align="left" valign="top"><p class="table">The tick unit type</p></td>
<td align="left" valign="top"><p class="table">Any string that can be parsed by Amount.valueOf</p></td>
<td align="left" valign="top"><p class="table">string</p></td>
<td align="left" valign="top"><p class="table">NO</p></td>
</tr>
</tbody>
</table>
</div>
<div class="tableblock">
<table rules="all"
width="60%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 5. Grid Attributes</caption>
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
<thead>
<tr>
<th align="left" valign="top">Attribute Id </th>
<th align="left" valign="top">Description </th>
<th align="left" valign="top">Allowed values </th>
<th align="left" valign="top">type </th>
<th align="left" valign="top">Required</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">Any attribute of int type</p></td>
<td align="left" valign="top"><p class="table">Any int attributes
will be used as the dimensions of the
grid. These will be processed in order
such that the first becomes the width
(x) dimensions, the next the height
(y) and so on.</p></td>
<td align="left" valign="top"><p class="table">Any int</p></td>
<td align="left" valign="top"><p class="table">int</p></td>
<td align="left" valign="top"><p class="table">YES</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">border rule</p></td>
<td align="left" valign="top"><p class="table">Specifies the behavior of agents
when moving over a grid&#8217;s borders.</p></td>
<td align="left" valign="top"><p class="table">bouncy, sticky, strict, or periodic</p></td>
<td align="left" valign="top"><p class="table">string</p></td>
<td align="left" valign="top"><p class="table">YES</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">allows multi</p></td>
<td align="left" valign="top"><p class="table">whether or not the grid allows multiple agents in
each cell</p></td>
<td align="left" valign="top"><p class="table">true or false (default is false)</p></td>
<td align="left" valign="top"><p class="table">boolean</p></td>
<td align="left" valign="top"><p class="table">NO</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>For example:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;context id="MyContext"&gt;
        &lt;projection id="MyGrid" type="grid"&gt;
                &lt;attribute id="width" type="int" value="200"/&gt;
                &lt;attribute id="height" type="int" value="100"/&gt;
                &lt;attribute id="border rule" type="string" value="periodic" /&gt;
                &lt;attribute id="allows multi" type="boolean" value="true"/&gt;
        &lt;/projection&gt;
&lt;/context&gt;</code></pre>
</div></div>
<div class="paragraph"><p>will create a 200x100 grid with an id of "MyGrid." The border rule for the grid
is "periodic" so the grid will wrap, forming a torus. The grid will also allow
multiple agents in each cell.</p></div>
<div class="tableblock">
<table rules="all"
width="60%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 6. Continuous Space Attributes</caption>
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
<thead>
<tr>
<th align="left" valign="top">Attribute Id </th>
<th align="left" valign="top">Description </th>
<th align="left" valign="top">Allowed values </th>
<th align="left" valign="top">type </th>
<th align="left" valign="top">Required</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">Any attribute of int or double type</p></td>
<td align="left" valign="top"><p class="table">Any int or double
attributes will be used as the dimensions of the grid. These will be
processed in order such that the first becomes the width (x) dimensions,
the next the height (y) and so on.</p></td>
<td align="left" valign="top"><p class="table">Any int or double</p></td>
<td align="left" valign="top"><p class="table">int or double</p></td>
<td align="left" valign="top"><p class="table">YES</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">border rule</p></td>
<td align="left" valign="top"><p class="table">Specifies the behavior of agents when moving over
a space&#8217;s borders.</p></td>
<td align="left" valign="top"><p class="table">bouncy, sticky, strict, or periodic</p></td>
<td align="left" valign="top"><p class="table">string</p></td>
<td align="left" valign="top"><p class="table">YES</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>For example:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;context id="MyContext"&gt;
        &lt;projection id="MySpace" type="continuous space"&gt;
                &lt;attribute id="width" type="int" value="200"/&gt;
                &lt;attribute id="height" type="int" value="100"/&gt;
                &lt;attribute id="border rule" type="string" value="strict" /&gt;
        &lt;/projection&gt;
&lt;/context&gt;</code></pre>
</div></div>
<div class="paragraph"><p>will create a 200x100 continuous space with an id of "MySpace." The border rule
for the grid is "strict" so any movement across the border will cause an error.</p></div>
<div class="tableblock">
<table rules="all"
width="60%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 7. Network Attributes</caption>
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
<thead>
<tr>
<th align="left" valign="top">Attribute Id </th>
<th align="left" valign="top">Description </th>
<th align="left" valign="top">Allowed values </th>
<th align="left" valign="top">type </th>
<th align="left" valign="top">Required</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">directed</p></td>
<td align="left" valign="top"><p class="table">Whether or not the network is directed</p></td>
<td align="left" valign="top"><p class="table">true or false. Default is false</p></td>
<td align="left" valign="top"><p class="table">boolean</p></td>
<td align="left" valign="top"><p class="table">NO</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">edge class</p></td>
<td align="left" valign="top"><p class="table">The fully qualified name of a class that
extends RepastEdge. Any edges created by the network will be
of this type.</p></td>
<td align="left" valign="top"><p class="table">Any properly formatted class name extending RepastEdge</p></td>
<td align="left" valign="top"><p class="table">string</p></td>
<td align="left" valign="top"><p class="table">NO</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>For example:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;context id="MyContext"&gt;
        &lt;projection id="MyNetwork" type="network"&gt;
                &lt;attribute id="directed" type="boolean" value="true"/&gt;
        &lt;/projection&gt;
&lt;/context&gt;</code></pre>
</div></div>
<div class="paragraph"><p>will create a network with an id of "MyNetwork." The network will be directed
and use the default RepastEdge as the edge type.</p></div>
</div>
<div class="sect2">
<h3 id="_distributing_your_model">2.2. Distributing Your Model</h3>
<div class="paragraph"><p>Models created with Repast Simphony may easily be distributed with the provided
Install Builder tool. This tool builds a distributable installer that anyone may
use to install the model to their computer. The only requirement for those to
who the model is distributed is the target system to have a current Java Runtime
Environment.</p></div>
<div class="paragraph"><p>To start the Install Builder, select Build Installer in the run menu</p></div>
<div class="paragraph"><p>The builder make take a few minutes to complete the installer. Once this process
is complete, a message "BUILD SUCCESSFUL" should be visible in the Console
window.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_repast_model_design_fundamental_concepts">3. Repast Model Design Fundamental Concepts</h2>
<div class="sectionbody">
<div class="paragraph"><p>Repast Simphony has an architectural design based on central principles
important to agent-based modeling. These principles combine findings from many
years of ABMS toolkit development and from experience applying the ABMS toolkits
to specific applications. There are a variety of design goals for Repast S
including the following:</p></div>
<div class="ulist"><ul>
<li>
<p>
There should be a strict separation between models, data storage, and
visualization.
</p>
</li>
<li>
<p>
Most toolkit functions should be available without having to implement
interfaces, extend classes, or manage proxies.
</p>
</li>
<li>
<p>
User model components should be ‘plain old Java objects’ (POJOs) that are
accessible to and replaceable with external software (e.g., legacy models and
enterprise information systems).
</p>
</li>
<li>
<p>
Common tasks should be automated when possible.
</p>
</li>
<li>
<p>
Imperative ‘boilerplate’ code should be eliminated or replaced with
declarative runtime configuration settings when possible.
</p>
</li>
<li>
<p>
Idiomatic code expressions (i.e., repeatedly used blocks of code such as loops
that scan lists of agents) should be simple and direct.
</p>
</li>
</ul></div>
<div class="sect2">
<h3 id="_contexts">3.1. Contexts</h3>
<div class="paragraph"><div class="title">Contexts and Projections</div><p>The Context is the core concept and object in Repast Simphony. It provides a
data structure to organize your agents from both a modelling perspective as well
as a software perspective. Fundamentally, a context is just a bucket full of
agents, but they provide more richness.</p></div>
<div class="paragraph"><p>The core data structure in Repast S is called a Context. The Context is a simple
container based on set semantics. Any type of object can be put into a Context
with the simple caveat that only one instance of any given object can be
contained by the Context. From a modeling perspective, the Context represents an
abstract population. The objects in a Context are the population of a model. For
simplicity, we refer to these objects as proto-agents. However, the Context does
not inherently provide any mechanism for interaction between proto-agents. One
could say that a Context represents a "soup" where the agents have no concept of
space or relation, but the Context is actually more of a proto-space. The Context
provides the basic infrastructure to define a population and the interactions of
that population without actually providing the implementations. As a proto-space,
the Context holds proto-agents that have idealized behaviors, but the behaviors
themselves cannot actually be realized until a structure is imposed on them.</p></div>
<div class="paragraph"><p>Repast S Contexts can be hierarchically nested to form a tree of parent Contexts
and their sub-Contexts. Contexts are containers for agents and projections.
Agents can join or leave Contexts at any time and can simultaneously exist in
multiple Contexts and sub-Contexts. Projections specify the relationship between
the agents in a given context. Projections include:</p></div>
<div class="ulist"><ul>
<li>
<p>
multidimensional discrete grids
</p>
</li>
<li>
<p>
multidimensional continuous spaces
</p>
</li>
<li>
<p>
networks
</p>
</li>
<li>
<p>
geographical information systems (GIS) spaces.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Each Context can contain as many projections as needed for a given model. Each
Projection in each Context defines a set of relationships between each the agent
in that context. For example, a Three Dimensional Continuous Space Projection in
a given Context defines the spatial relationship (i.e., Euclidean distance)
between each agent. A Network Projection containing social relationships in the
same Context might define friendship relations between the agents. A second
Network Projection in the given Context might define family relationships
between the agents.</p></div>
<div class="paragraph"><div class="title">Queries</div><p>Repast S provides a mechanism to query a model&#8217;s Context hierarchy and the
associated Projections and agents. This mechanism provides methods to find
agents with specific types, agents with selected individual properties, and
agents with given Projections properties (e.g., agents at a given location in a
grid or agents with given kinds of links to other agents).</p></div>
<div class="paragraph"><p>Queries are defined using the following conceptual predicates:</p></div>
<div class="ulist"><ul>
<li>
<p>
<strong>Equals</strong>: This predicate determines whether the object is equal to a given
object.
</p>
</li>
<li>
<p>
<strong>Property equals</strong>: This predicate determines whether a property in the object
is equal to a given value.
</p>
</li>
<li>
<p>
<strong>Property less than</strong>: This predicate determines whether a property in the
object is less than a given value.
</p>
</li>
<li>
<p>
<strong>Property greater than</strong>: This predicate determines whether a property in the
object is greater than a given value.
</p>
</li>
<li>
<p>
<strong>Network adjacent</strong>: This predicate determines whether the object is linked to
a given object in a specified network.
</p>
</li>
<li>
<p>
<strong>Network successor</strong>: This predicate determines whether the object has an
inbound edge from a given object in a specified network.
</p>
</li>
<li>
<p>
<strong>Network predecessor</strong>: This predicate determines whether the object has an
outbound edge to a given object in a specified network.
</p>
</li>
<li>
<p>
<strong>Touches</strong>: This GIS predicate determines whether the object touches a given
object in space.
</p>
</li>
<li>
<p>
<strong>Contained by</strong>: This GIS predicate determines whether the object is contained
by a given object in space.
</p>
</li>
<li>
<p>
<strong>In envelope</strong>: This GIS predicate determines whether the object is within a
given envelope (bounding box) in space.
</p>
</li>
<li>
<p>
<strong>And</strong>: This predicate implements intersection.
</p>
</li>
<li>
<p>
<strong>Or</strong>: This predicate implements union.
</p>
</li>
<li>
<p>
<strong>Not</strong>: This predicate implements negation.
</p>
</li>
<li>
<p>
<strong>Von Neumann</strong>: This predicate determines whether an object is within the Von
Neumann neighborhood of a given object in a grid.
</p>
</li>
<li>
<p>
<strong>Moore</strong>: This predicate determines whether an object is within the Moore
Neighborhood of a given object in a grid.
</p>
</li>
<li>
<p>
<strong>Within distance</strong>: This GIS and non-GIS predicate determines whether the
object is within a given distance of a specified object in a GIS space, a
non-GIS grid or continuous space, or within a given path length in a network.
Concrete subclasses implement specific functions for each projection type.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Searches that utilize these conceptual predicates can also be performed
imperatively using Java syntax or declaratively using watcher syntax. Both of
these approaches are discussed later in this section. Groovy uses the same
syntax as Java for the predicates. When used in an imperative mode, queries
normally return a list scanning object or Iterator. These iterators can be used
in programmed agent behaviors to operate on and react to members of the list.</p></div>
<div class="paragraph"><div class="title">Watches</div><p>The Repast S Watcher mechanism builds on the Context hierarchy and query system
to provide behavioral triggers. Watchers allow modelers to easily:</p></div>
<div class="ulist"><ul>
<li>
<p>
Define queries to find other agents to monitor
</p>
</li>
<li>
<p>
Define properties of other agents to be monitored
</p>
</li>
<li>
<p>
Define activation conditions of the monitored properties and other properties
</p>
</li>
<li>
<p>
Specify the time for a response if the activation conditions are triggered
</p>
</li>
<li>
<p>
Specify the behavior to invoke when the activation conditions are triggered
</p>
</li>
</ul></div>
<div class="paragraph"><p>The Repast Watchers are efficiently implemented using dynamic code generation
that instruments the monitored agents with the needed behavioral activation
checks.</p></div>
<div class="paragraph"><p>Repast Simphony&#8217;s combination of Contexts, Projections, Queries, and Watchers
provides a powerful and flexible environment for ABMS implementation.</p></div>
<div class="sect3">
<h4 id="_finding_contexts">3.1.1. Finding Contexts</h4>
<div class="paragraph"><p>The Repast <em>ContextUtils</em> class provides a number of utility functions for finding
Context instances from the model code.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/tip.png" alt="Tip" />
</td>
<td class="content">Generally there is no need to store local references to Contexts (say
within an agent) since the Context in which an agent resides can always be
referenced.</td>
</tr></table>
</div>
<div class="paragraph"><p>To reference the current context of an agent:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Context context = ContextUtils.getContext (agent)</code></pre>
</div></div>
<div class="paragraph"><p>The context&#8217;s parent context (if exists) can similarly be found using:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Context parentContext = ContextUtils.getParentContext (context)</code></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_adding_and_removing_objects_in_contexts">3.1.2. Adding and Removing Objects in Contexts</h4>
<div class="paragraph"><p>The Repast <em>Context</em> interface extends the standard Java <em>Collection</em> so that
objects can be added or removed to or from contexts similar to how one would
perform such operations with Java collections such as lists.</p></div>
<div class="ulist"><ul>
<li>
<p>
To add an object to a context:
</p>
<div class="listingblock">
<div class="content">
<pre><code>context.add(object);</code></pre>
</div></div>
</li>
<li>
<p>
To remove an object from a context:
</p>
<div class="listingblock">
<div class="content">
<pre><code>context.remove(object);</code></pre>
</div></div>
</li>
<li>
<p>
Similarly, to add a context that is a subcontext:
</p>
<div class="listingblock">
<div class="content">
<pre><code>context.addSubContext(subContext);</code></pre>
</div></div>
</li>
<li>
<p>
To remove a context that is a subcontext:
</p>
<div class="listingblock">
<div class="content">
<pre><code>context.removeSubContext(subContext);</code></pre>
</div></div>
</li>
</ul></div>
</div>
<div class="sect3">
<h4 id="_finding_objects_in_contexts">3.1.3. Finding Objects in Contexts</h4>
<div class="paragraph"><p>Objects (typically agents) contained in a context can be referenced in several
ways.</p></div>
<div class="ulist"><ul>
<li>
<p>
To get a single random object from a reference:
</p>
<div class="listingblock">
<div class="content">
<pre><code>Object o = context.getRandomObject();</code></pre>
</div></div>
</li>
<li>
<p>
To get a random iterable collection of some (count) objects of a specific
class:
</p>
<div class="listingblock">
<div class="content">
<pre><code>Iterable collection = context.getRandomObjects(MyClass.class, count);</code></pre>
</div></div>
</li>
<li>
<p>
To get a random iterable collection of all objects of a specific class:
</p>
<div class="listingblock">
<div class="content">
<pre><code>IndexedIterable collection = context.getObjects(MyClass.class);</code></pre>
</div></div>
</li>
</ul></div>
<div class="paragraph"><p>The typical way to access the objects in the returned iterable collections is:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>for (Object o : collection){
        // do something with o here.
}</code></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_implementing_custom_contexts">3.1.4. Implementing Custom Contexts</h4>
<div class="paragraph"><p>User models can implement their own custom Context implementations, either by
creating a complete <em>Context</em> interface implementation from scratch, or by
extending the Repast <em>DefaultContext</em> class.  Extending <em>DefaultContext</em> is the
recommended route since the default implementation contains all of the working
implementations for the <em>Context</em> interface.  User context imlplementations can
be used in model code in exactly the same way as the default Repast Context.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_context_loading">3.2. Context Loading</h3>
<div class="paragraph"><p>Context loading is the process of populating the root model context with agents,
projections, and sub-contexts and occurs when a model run is initialized, and
may be thought of as the model&#8217;s "main" function that assembles the model
components.  The Repast <em>ContextBuilder</em> interface is used for model
implementations that perform context loading:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>/**
* Interface for classes that build a Context by adding projections,
* agents and so forth.
*/
        public interface ContextBuilder&lt;T&gt; {
        /**
        * Builds and returns a context. Building a context consists of filling it with
        * agents, adding projects and so forth. The returned context does not necessarily
        * have to be the passed in context.
        *
        * @param context
        * @return the built context.
        */
        Context build(Context&lt;T&gt; context);
}</code></pre>
</div></div>
<div class="paragraph"><p>Models should include a single <em>ContextBuilder</em> implementation.  The context
argument in the <code>build()</code> method is an instance of the Repast DefaultContext
that can be populated and returned.  A custom user-defined Context
implementation could be created and returned instead of the default provided
context.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/tip.png" alt="Tip" />
</td>
<td class="content">All of the Repast Simphony models implemented in Java use a ContextBuilder to
create the main context and populate it with agents.</td>
</tr></table>
</div>
<div class="paragraph"><p>The ContxtBuilder is called by the Repast runtime at initialization, but the
implementing user model class (e.g. MyContextBuilder) is not specified in the
scenario.xml file until it is set via the runtime menu option.  To specify the
user-defined ContextBuilder, see the section on <a href="#DataLoaders">Data Loaders</a>.</p></div>
</div>
<div class="sect2">
<h3 id="_projections">3.3. Projections</h3>
<div class="paragraph"><p>While Contexts create a container to hold your agents, Projections impose a
structure upon those agents. Simply using Contexts, one could never write a
model that provided more than a simple "soup" for the agents. The only way to
reference other agents would be randomly. Projections allow the modeller to
create a structure that defines relationships, whether they be spatial, network,
or something else. A projection os attached to a particular Context and applies
to all of the agents in that Context. This raises an important point:</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/important.png" alt="Important" />
</td>
<td class="content">An object (agent) must exist in a Context before it can be used in a
projection.</td>
</tr></table>
</div>
<div class="paragraph"><p>Multiple projections can be addeded to the same context therefore it is possible,
for example, for a context to contain a grid, a geography, and a network.</p></div>
<div class="paragraph"><p>Agents may reference projections through their containing context by specifying
the name of the projections, e.g. "mynetwork":</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Context context = ContextUtils.getContext (this)
Projection projection = context.getProjection("mynetwork");</code></pre>
</div></div>
<div class="paragraph"><p>The returned Projection object will have limited value unless is is cast to the
specific type (e.g. Network or Grid):</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Context context = ContextUtils.getContext (this)
Network network = (Network)context.getProjection("mynetwork");</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_creating_projections">3.4. Creating Projections</h3>
<div class="paragraph"><p>In general, projections are created using a factory mechanism in the following
way.</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Find the factory
</p>
</li>
<li>
<p>
Use the factory to create the projection
</p>
</li>
</ol></div>
<div class="listingblock">
<div class="content">
<pre><code>Context&lt;SimpleHappyAgent&gt; context = Contexts.createContext(SimpleHappyAgent.class, "my context");
GridFactory factory = GridFactoryFinder.createGridFactory(new HashMap());
Grid grid = factory.createGrid("Simple Grid", context, ...);
Context&lt;SimpleHappyAgent&gt; context = Contexts.createContext(SimpleHappyAgent.class, "mycontext");</code></pre>
</div></div>
<div class="listingblock">
<div class="content">
<pre><code>ContinuousSpaceFactory factory = ContinuousSpaceFactoryFinder.createContinuousSpaceFactory(new HashMap());
ContinuousSpace space = factory.createContinuousSpace("Simple Space", context, ...);</code></pre>
</div></div>
<div class="paragraph"><p>Each factory creates a projection of a specific type and requires the context
that the projection is associated with and the projections name as well as
additional arguments particular to the projection type. These additional
arguments are marked above with "&#8230;" and are explicated on the individual pages
for that projection.</p></div>
</div>
<div class="sect2">
<h3 id="_grid_projections">3.5. Grid Projections</h3>
<div class="paragraph"><p>Grids are a mainstay of agent based simulation. Many of the earliest simulation such as Schelling&#8217;s
Dynamic Models of Segregation, heatbugs, and sugarscape were originally built on grids. Basically a grid,
for our purposes, are a 1 or more dimensional data structure that is divided up into a number of cells.
These cells can be referenced by their integer coordinates. In other words, a grid is an n-dimensional
matrix. Even though grids have been used in agent based simulation since it&#8217;s inception (and before),
they still have value today. These data structures are very efficient and provide a number of different
ways to define neighborhoods. While they don&#8217;t offer the flexibility of an abstract network or the realism
of a continuous or GIS space, the grid can be used to simulate spaces and to create highly structured
relationships between agents. While most people think of grids to represent space, there is no reason
why a grid couldn&#8217;t be used define more abstract kinds of relationships. No matter how you look at it,
grids are still a powerful tool in an overall agent based toolkit.</p></div>
<div class="paragraph"><div class="title">Repast Simphony&#8217;s Grid support</div><p>Repast Simphony provides a rich set of tools to work with grids of all kinds. Specifically, it supports
* 2D, 3D and ND grids,
* querying for Von Neumann and Moore neighborhoods,
* Toroidal, Reflective and Fixed Border conditions.</p></div>
<div class="paragraph"><div class="title">Creating A Grid</div><p>Creating a grid in Repast Simphony is similar to creating the other projections. Your agents must exist in
the context in order to exist in the grid, and you want to create the grid using a factory to make sure that
it is initialized properly.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>GridFactory factory = GridFactoryFinder.createGridFactory(new HashMap());
Grid grid = factory.createGrid("My Grid", context, gridBuilderParameters);</code></pre>
</div></div>
<div class="paragraph"><p>So, most of that is pretty straight forward, eh? Pass the method a name (so that you can look up your
grid later) and the context that will back the grid. But what is that last argument? The
gridBuilderParameters. GridBuilderParameters are used to specify the properties of the grid itself, such
as its dimensions, its border behavior, and how agents are initially added to the grid.</p></div>
<div class="paragraph"><div class="title">GridBuilderParameters</div><p>The GridBuilderParameters class contains a variety of static methods for creating specific types of
GridBuilderParameters. For example,</p></div>
<div class="listingblock">
<div class="content">
<pre><code>GridBuilderParameters params = GridBuilderParameters.singleOccupancy2DTorus(
                new SimpleAdder&lt;Agent&gt;(), 10, 10);</code></pre>
</div></div>
<div class="paragraph"><p>will create parameters for a 10x10 torus where each cell can only have a single occupant. Other static
methods (see the javadocs) allow you to create other types of grids. In general though, youwill always
have to specify a GridAdder and perhaps a GridPointTranslator when creating GridBuilderParameters. You
will also have to specify the dimensions. These will be the last arguments to the method.</p></div>
<div class="paragraph"><div class="title">Adders</div><p>Like most projections, an object doesn&#8217;t exist in the projection until it is added to the context, and once it
is added to the context, it is automatically added to the projection. But where do we put it in the grid?
That&#8217;s where the GridAdder interface comes in. The adder allows you to specify where to place an object
once it has been added to the context. It has a simple method:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>public void add(Grid destination, U object);</code></pre>
</div></div>
<div class="paragraph"><p>More generics fun, eh? Well, it&#8217;s not so bad. In this case, the destination is the type of projection to
which we are adding our object (a grid). Object is the object we want to add to that projection. So, &lt;U&gt;
is whatever we&#8217;re adding. Basically, to implement this interface, you just take in an object and do
something with it in the supplied projection. Ok, let&#8217;s get a bit more concrete. Let&#8217;s say that we have a
Grid and when an object is added to the grid, we want to locate it randomly. Here is the implementation
for that:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>public void add(Grid&lt;T&gt; space, T obj) {
        Dimensions dims = space.getDimensions();
        int[] location = new int[dims.size()];
        findLocation(location, dims);
        while (!space.moveTo(obj, location)) {
                findLocation(location, dims);
        }
}

private void findLocation(int[]location, Dimensions dims) {
        for (int i = 0; i &lt; location.length; i++) {
                location[i] = RandomHelper.getDefault().nextIntFromTo(0, dims.getDimension(i) -1);
        }
}</code></pre>
</div></div>
<div class="paragraph"><p>The add method randomly generates locations and puts the objects into that location (assuming the grid
allows the object to be there). This little bit of code sets up a random space for you as you add agents.
Not surprisingly, this is the code for the RandomGridAdder which comes with Repast Simphony. This
behaviour may not be what you want. The most basic Adder we provide is the SimpleAdder; This Adder
doesn&#8217;t actually locate the object anywhere in the grid. It just allows the object to be used in the grid.
The object won&#8217;t appear to have a location until you call</p></div>
<div class="listingblock">
<div class="content">
<pre><code>grid.moveTo(object, x, y);</code></pre>
</div></div>
<div class="paragraph"><p>This is a very useful adder because you don&#8217;t have to know where the agent is supposed to be located in
advance. Let&#8217;s look at one example of writing your own Adder. In this case, let&#8217;s assume that our agents have
their grid coordinates stored. The adder just needs to use those coordinates to locate the agents
properly. We&#8217;ll call the Interface Located:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>public interface Located{
        public int getX();
        public int getY();
}</code></pre>
</div></div>
<div class="paragraph"><p>Pretty simple, eh? Let&#8217;s write an adder that know how to work with this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>public class LocatedAdder&lt;Located&gt; implements GridAdder&lt;Located&gt; {
        public void add(Grid&lt;Located&gt; grid, Located object){
                grid.moveTo(object, object.getX(), object.getY());
        }
}</code></pre>
</div></div>
<div class="paragraph"><p>This will add the object to the grid at the location specified by the agent itself. This doesn&#8217;t handle any
errors or anything, but it should give you an idea of how to create your own adder.</p></div>
<div class="paragraph"><div class="title">GridPointTranslators</div><p>A GridPointTranslator determines the border behavior of a grid. The border behavior is what happens
when an agents moves past the border of a grid. Five kinds of border behavior classes are described
below together with a description of how the behave in response to a Grid&#8217;s moveTo and moveBy (the
moveBy methods are moveByDisplacement and moveByVector) methods.</p></div>
<div class="ulist"><ul>
<li>
<p>
StrictBorders&#8201;&#8212;&#8201;defines a strict boundary that cannot be crossed without throwing a
SpatialException. Consequently, any moveTo or moveBy across the border will throw an exception.
</p>
</li>
<li>
<p>
StickyBorders&#8201;&#8212;&#8201;defines a "sticky" border that to which an agent will "stick" in a moveBy. However,
a moveTo across the border will still throw a SpatialException.
</p>
</li>
<li>
<p>
InfiniteBorders&#8201;&#8212;&#8201;defines infinite borders that the agent will never cross.
</p>
</li>
<li>
<p>
BouncyBorders&#8201;&#8212;&#8201;defines a bouncy border that the agent will bounce off at the appropriate angle in
a moveBy. However, a moveTo across the border will still throw a SpatialException.
</p>
</li>
<li>
<p>
WrapAroundBorders&#8201;&#8212;&#8201;defines borders that wrap around to their opposite borders. This mean
moveTo and moveBy across the border will cross the border and enter the opposite side. A 2D grid
with WrapAroundBorders is a torus.
In general then, moveTo will throw a SpatialException when crossing the border and moveBy will invoke
the border behavior.
</p>
</li>
</ul></div>
<div class="paragraph"><div class="title">Moving on a Grid</div><p>Movement on the grid is accomplished with 3 methods.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>moveTo(T object, int... newLocation)</code></pre>
</div></div>
<div class="paragraph"><p>This specifies the object to move and the new location to move to. It will return true if the move
succeeds, for example, if the location is unoccupied an single occupancy grid and the new location doesn&#8217;t
violate any border behaviors. This method can be used to introduce objects into the grid if they do not yet have a grid location. This will throw a SpatialException if the object is not already in the space, if the
number of dimensions in the location does not agree with the number in the space, or if the object is
moved outside the grid dimensions.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>GridPoint moveByDisplacement(T object, int... displacement)</code></pre>
</div></div>
<div class="paragraph"><p>Moves the specified object from its current location by the specifiedamount. For example,
moveByDisplacement(object, 3, -2, 1) will move the object by 3 along the x-axis, -2 along the y and 1
alongthe z. The displacement argument can be less than the number of dimensions in the space in which
case the remaining argument will beset to 0. For example, moveByDisplacement(object, 3) will move the
object 3 along the x-axis and 0 along the y and z axes, assuming a 3D grid. This will return the new
location as a GridPoint if the move was successful, otherwise it will return null. Like moveTo it will throw a
SpatialException if the object is not already in the space or if the number of dimensions in the
displacement is greater than the number of grid dimensions.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>GridPoint moveByVector(T object, double distance, double... anglesInRadians)</code></pre>
</div></div>
<div class="paragraph"><p>Moves the specifed object the specified distance from its current position along the specified angle. For
example, moveByVector(object, 1, Direction.NORTH) will move the object 1 unit "north" up the y-axis,
assuming a 2D grid. Similarly, grid.moveByVector(object, 2, 0, Math.toRadians(90), 0) will rotate 90
egrees around the y-axis, thus moving the object 2 units along the z-axis. Note that the radians /
degrees are incremented in a anti-clockwise fashion, such that 0 degrees is "east", 90 degrees is "north",
180 is "west" and 270 is "south." This will return the new location as a GridPoint if the move was
successful, otherwise it will return null. Like moveTo it will throw a SpatialException if the object is not
already in the space or if the number of dimensions in the displacement is greater than the number of
grid dimensions.
Document</p></div>
</div>
<div class="sect2">
<h3 id="_continuous_space_projection">3.6. Continuous Space Projection</h3>
<div class="paragraph"><p>A continuous (real valued) space projection is a space in which an agents
location is represented by floating point coordinates. For example, one agent
may be at the point 2.133, 0 and another may be at 21.1, 234. This contrasts
with the discrete integer valued grid projections. However, much of the behavior
of a continuous space like that of the grid, so it maybe worthwhile reading
those Grid Projections pages first.</p></div>
<div class="paragraph"><p>Repast Simphony provides a rich set of tools to work with grids of all kinds.
Specifically, it supports</p></div>
<div class="ulist"><ul>
<li>
<p>
1D, 2D, 3D and ND continuous spaces,
</p>
</li>
<li>
<p>
Toroidal, Reflective and Fixed Border conditions.
</p>
</li>
</ul></div>
<div class="paragraph"><div class="title">Creating A Continuous Space</div><p>Creating a continuous space in Repast Simphony is similar to creating the other
projections. Your agents must exist in the context in order to exist in the
continuous space, and you want to create the continuous spaceusing a factory to
make sure that it is initialized properly.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>ContinuousSpace factory = ContinuousSpaceFactoryFinder.createGridFactory(new HashMap());
ContinuousSpace space = factory.createContinuousSpace("My Space", context,
        continuousAdder, pointTranslator, 10, 10);</code></pre>
</div></div>
<div class="paragraph"><p>So, most of that is pretty straight forward, eh? Pass the method a name (so that you can look up your
grid later) and the context that will back the continuous space. But what of these additional arguments.
Like the Grid, an Adder must be specified as well as a PointTranslator and the dimensions of the grid.</p></div>
<div class="paragraph"><div class="title">Adders</div><p>Like most projections, an object doesn&#8217;t exist in the projection until it is added to the context, and once it
is added to the context, it is automatically added to the projection. But where do we put it in the
continuous space? That&#8217;s where the ContinuousSpaceAdder interface comes in. The adder allows you to
specify where to place an object once it has been added to the context. It has a simple method:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>public void add(ContinuousSpace destination, U object);</code></pre>
</div></div>
<div class="paragraph"><p>More generics fun, eh? Well, it&#8217;s not so bad. In this case, the destination is the projection to which we
are adding our object (ContinuousSpace). Object is the object we want to add to that projection. So,
&lt;U&gt; is whatever we&#8217;re adding. Basically, to implement this interface, you just take in an object and do
something with it in the supplied projection. Ok, let&#8217;s get a bit more concrete. Let&#8217;s say that we have a
ContinuousSpace and when an object is added to the continuous space, we want to locate it randomly.
Here is the implementation for that:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>public void add(ContinuousSpace&lt;T&gt; space, T obj) {
        Dimensions dims = space.getDimensions();
        double[] location = new double[dims.size()];
        findLocation(location, dims);
        while (!space.moveTo(obj, location)) {
                findLocation(location, dims);
        }
}
private void findLocation(double[] location, Dimensions dims) {
        for (int i = 0; i &lt; location.length; i++) {
                location[i] = RandomHelper.getDefault().nextDoubleFromTo(0,dims.getDimension(i) - 1);
        }
}</code></pre>
</div></div>
<div class="paragraph"><p>The add method randomly generates locations and puts the objects into that location (assuming the grid
allows the object to be there). This little bit of code sets up a random space for you as you add agents.
Not surprisingly, this is the code for the RandomCartesianAdder which comes with Repast Simphony.
This behaviour may not be what you want. The most basic Adder we provide is the
SimpleCartesianAdder. This Adder doesn&#8217;t actually locate the object anywhere in the grid. It just allows
the object to be used in the grid. The object won&#8217;t appear to have a location until you call</p></div>
<div class="listingblock">
<div class="content">
<pre><code>continuousSpace.moveTo(object, x, y);</code></pre>
</div></div>
<div class="paragraph"><p>This is a very useful adder because you don&#8217;t have to know where the agent is supposed to be located in
advance.</p></div>
<div class="paragraph"><p>Let&#8217;s look at one example of writing your own Adder. In this case, let&#8217;s assume that our agents have
their continuous space coordinates stored. The adder just needs to use those coordinates to locate the
agents properly. We&#8217;ll call the Interface Located:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>public interface Located{
        public int getX();
        public int getY();
}</code></pre>
</div></div>
<div class="paragraph"><p>Pretty simple, eh? Let&#8217;s write an adder that know how to work with this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>public class LocatedAdder&lt;Located&gt; implements ContinuousAdder&lt;Located&gt; {
        public void add(ContinuousSpace&lt;Located&gt; grid, Located object){
                grid.moveTo(object, object.getX(), object.getY());
        }
}</code></pre>
</div></div>
<div class="paragraph"><p>This will add the object to the grid at the location specified by the agent itself. This doesn&#8217;t handle any
errors or anything, but it should give you an idea of how to create your own adder.</p></div>
<div class="paragraph"><div class="title">PointTranslators</div><p>Just like the GridPointTranlator described on the Grid&#8217;s page, a PointTranslator determines the border
behavior of a continuous space. The border behavior is what happens when an agents moves past the
border of a continuous space. Five kinds of border behavior classes are described below together with a
description of how they behave in response to a continuous space&#8217;s moveTo and moveBy* (the moveBy*
methods are moveByDisplacement and moveByVector) methods.</p></div>
<div class="ulist"><ul>
<li>
<p>
StrictBorders&#8201;&#8212;&#8201;defines a strict boundary that cannot be crossed without throwing a
SpatialException. Consequently, any moveTo or moveBy across the border will throw an exception.
</p>
</li>
<li>
<p>
StickyBorders&#8201;&#8212;&#8201;defines a "sticky" border that to which an agent will "stick" in a moveBy. However,
a moveTo across the border will still throw a SpatialException.
</p>
</li>
<li>
<p>
InfiniteBorders&#8201;&#8212;&#8201;defines infinite borders that the agent will never cross.
</p>
</li>
<li>
<p>
BouncyBorders&#8201;&#8212;&#8201;defines a bouncy border that the agent will bounce off at the appropriate angle in
a moveBy. However, a moveTo across the border will still throw a SpatialException.
</p>
</li>
<li>
<p>
WrapAroundBorders&#8201;&#8212;&#8201;defines borders that wrap around to their opposite borders. This mean
moveTo and moveBy across the border will cross the border and enter the opposite side.
</p>
</li>
</ul></div>
<div class="paragraph"><p>In general then, moveTo will throw a SpatialException when crossing the border and moveBy* will invoke
the border behavior.</p></div>
<div class="paragraph"><div class="title">Moving in a Continuous Space</div><p>Movement on a continuous space is accomplished with 3 methods.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>moveTo(T object, double... newLocation)</code></pre>
</div></div>
<div class="paragraph"><p>This specifies the object to move and the new location to move to. It will return true if the move
succeeds, for example, if the new location doesn&#8217;t violate any border behaviors. This method can be used
to introduce objects into the grid if they do not yet have a grid location. This will throw a SpatialException
if the object is not already in the space, if the number of dimensions in the location does not agree with
the number in the space, or if the object is moved outside the continuous space&#8217;s dimensions.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>NdPoint moveByDisplacement(T object, double... displacement)</code></pre>
</div></div>
<div class="paragraph"><p>Moves the specified object from its current location by the specified amount. For example,
moveByDisplacement(object, 3, -2, 1) will move the object by 3 along the x-axis, -2 along the y and 1
along the z. The displacement argument can be less than the number of dimensions in the space in which
case the remaining arguments will be set to 0. For example, moveByDisplacement(object, 3) will move
the object 3 along the x-axis and 0 along the y and z axes, assuming a 3D continuous space. This will
return the new location as a NdPoint if the move was successful, otherwise it will return null. Like moveTo
it will throw a SpatialException if the object is not already in the space or if the number of dimensions in
the displacement is greater than the number of continuous space dimensions.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>NdPoint moveByVector(T object, double distance, double... anglesInRadians)</code></pre>
</div></div>
<div class="paragraph"><p>Moves the specifed object the specified distance from its current position along the specified angle. For
example, moveByVector(object, 1, Direction.NORTH) will move the object 1 unit "north" up the y-axis,
assuming a 2D continuous space. Similarly, grid.moveByVector(object, 2, 0, Math.toRadians(90), 0) will
rotate 90 egrees around the y-axis, thus moving the object 2 units along the z-axis. Note that the radians
/ degrees are incremented in a anti-clockwise fashion, such that 0 degrees is "east", 90 degrees is
"north", 180 is "west" and 270 is "south." This will return the new location as a NdPoint if the move was
successful, otherwise it will return null. Like moveTo it will throw a SpatialException if the object is not
already in the space or if the number of dimensions in the displacement is greater than the number of
continuous space dimensions.</p></div>
</div>
<div class="sect2">
<h3 id="_network_projections">3.7. Network Projections</h3>
<div class="paragraph"><p>Many models use abstract relationships between agents using Networks or Graphs. These connections
may represent social connections, physical infrastructure connections or some other abstract
connections. Repast provides tools to work with Networks or Graphs easily as a Projection. The default
support for networks is supplied by the excellent library JUNG.</p></div>
<div class="paragraph"><div class="title">Building a Network</div><p>In many situations, you won&#8217;t need to build the network yourself. If you are using a persistent Data
Loader to load the network from a freezedryed instance the networks will be generated for you.
However, if you using your own ContextBuilder or you wish to create networks during your simulation,
you will need to be able to build networks in code.</p></div>
<div class="paragraph"><p>The first thing to remember when working with networks is that, like most projections, in order to
participate in a network, and agent must already exist in the context. A side affect of this is that any
agent in a context is automatically a member of any networks associated with that context. The agent
might not have any edges, but they will be in the network for all intents and purposes.</p></div>
<div class="paragraph"><div class="title">Network Builders</div><p>Networks are created using a NetworkBuilder. The NetworkBuilder class allows the user to tune the
network creation to create specific kinds of networks. This "tuning" is done by calling various methods on
the builder. If none of these methods are called then a simple "plain vanilla" network is created. For
example,</p></div>
<div class="listingblock">
<div class="content">
<pre><code>NetworkBuilder builder = new NetworkBuilder("Network", context, true);
Network network = builder.buildNetwork()</code></pre>
</div></div>
<div class="paragraph"><p>The first argument to the builder constructor is the name of the network, the second is the context which
the network "projects" and the last is whether or not the network is directed. By default, the
addEdge(source, target, &#8230;) methods of a network will create and use an instance of RepastEdge as the
edge between the source and target. Using the builder, you can customize this edge creation process by
specifying an EdgeCreator on the NetworkBuilder. The EdgeCreator interface looks like:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>/**
* Factory class for creating edges.
*
* @author Nick Collier
*/
public interface EdgeCreator&lt;E extends RepastEdge, T&gt; {

        /**
        * Gets the edge type produced by this EdgeCreator.
        *
        * @return the edge type produced by this EdgeCreator.
        */
        Class getEdgeType();

        /**
        * Creates an Edge with the specified source, target, direction and weight.
        *
        * @param source the edge source
        * @param target the edge target
        * @param isDirected whether or not the edge is directed
        * @param weight the weight of the edge
        * @return the created edge.
        */
        E createEdge(T source, T target, boolean isDirected, double weight);
}</code></pre>
</div></div>
<div class="paragraph"><p>The intention is that the user implement the createEdge method to customize the edge creation process.
All edges created on the network via addEdge(source, target, &#8230;) will forward edge creation to this
method. Specifying the edge creator on the builder looks like:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>NetworkBuilder builder = new NetworkBuilder("Network", context, true);
builder.setEdgeCreator(myEdgeCreator);
Network network = builder.buildNetwork()</code></pre>
</div></div>
<div class="paragraph"><p>Any networks created using this builder will then use that EdgeCreator.</p></div>
<div class="paragraph"><p>Networks can also be loaded from a file. Currently, the builder can load networks from UCINet&#8217;s dl format
or from Excel. The relevant methods in the NetworkBuilder are:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>/**
* Sets this NetworkBuilder to create the network from a file. This
* will use the first network found in the file.
*
* @param fileName the name of the file to load from
* @param format the format of the file
* @param nodeCreator a node creator that will be used to create the agents / nodes
* @return this NetworkBuilder
* @throws IOException if there is a file related error
*/
public NetworkBuilder load(String fileName, NetworkFileFormat format,
        NodeCreator nodeCreator) throws IOException

/**
* Sets this NetworkBuilder to create the network from a file. This
* will use the first network found in the file.
*
* @param fileName the name of the file to load from
* @param format the format of the file
* @param nodeCreator a node creator that will be used to create the agents / nodes
* @param matrixIndex the index of the matrix in the file to load. Starts with 0.
* @return this NetworkBuilder
* @throws IOException if there is a file related error
*/
public NetworkBuilder load(String fileName, NetworkFileFormat format,
        NodeCreator nodeCreator, int matrixIndex) throws IOException</code></pre>
</div></div>
<div class="paragraph"><p>The NodeCreator in the above is used to perform the actual node / agent creation based on the
information in the network file. These nodes are added to the context and edges between them are
created using the link data from the file. The NetworkFileFormat is either NetworkFileFormat.DL or
NetworkFileFormat.EXCEL, although more formats may be added in the future. The Excel file format is
described below.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>The matrix is assumed to be square.

Each worksheet is treated as a matrix, and any worksheets
that do not contain matrices will cause an error. The worksheet name
is treated as the matrix label unless the name begins with Sheet
(Excel's generic worksheet name). The format for excel files is that
imported and exported by UCINet. The first cell is empty, and the
node labels begin on this first row in the second column. The column
node labels begin in first column on the second row. The actual data
begins in cell 2,2. For example,
| first_label | second_label | ...
-----------+-----------+--------------+----
first_label | 0 | 1 | ...
-----------+----------+---------------+----
second_label | 1 | 0 | ...
-------------+-------------+--------------+----
... | ... | ... | ...
If the matrix has no node labels, repast will expect the first row and
column to be blank and as before, for the data to begin in cell 2,2.&lt;p&gt;</code></pre>
</div></div>
<div class="paragraph"><p>An example of the network builder loading a file:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>NetworkBuilder builder = new NetworkBuilder("Network", context, true);
builder.load("./repast.simphony.core/test/repast/simphony/graph/matrices.xls",
NetworkFileFormat.EXCEL, myNodeCreator);
Network net = builder.buildNetwork();</code></pre>
</div></div>
<div class="paragraph"><p>Lastly, a NetworkGenerator can be set on the NetworkBuilder. NetworkGenerators typically assume that
the context already contains the nodes / agents and the generator arranges them in the appropriate
topography (e.g. a Small World). For example,</p></div>
<div class="listingblock">
<div class="content">
<pre><code>// make sure the agents are in the context before
// creating the network with the generator
for (int i = 0; i &lt; 25; i++) {
        VizAgent agent = new VizAgent("Agent-" + i);
        context.add(agent);
}
NetworkGenerator gen = new WattsBetaSmallWorldGenerator(.2, 2, false);
NetworkBuilder builder = new NetworkBuilder("Electricity Network", context, true);
builder.setGenerator(gen);
Network net = builder.buildNetwor();</code></pre>
</div></div>
<div class="paragraph"><p>The arguments to the generator are the probability of rewiring the network, the local neighborhood size,
and whether or not generated edges will be created symmetrically. We then create a NetworkFactory and
use that to create the network, passing it the network name, the context, the generator, and whether or
not the resulting network will be directed. In this case, the generator creates a small world type network
using the agents in the context as nodes.</p></div>
<div class="paragraph"><p>See the repast.simphony.context.space.graph package for more information on NetworkGenerators and
what is available.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/note.png" alt="Note" />
</td>
<td class="content">Although the generators supplied by simphony do assume that the context already contains
nodes / agents, the NetworkGenerator interface is flexible and can be used to implement any sort of
custom network creation. For example, the network file loaders are actually implements as
NetworkGenerators whose constructors take the necessary NodeCreator etc. information.</td>
</tr></table>
</div>
<div class="paragraph"><div class="title">Working with a network</div><p>Once you have a network, you can always add Relationships, but that&#8217;s not really that useful until you
can query based on the relationships. The Network library provides all of the methods you would expect
to have to access the objects and relationships in it. The particular methods in which you will be
interested are:
* getAdjacent(agent) - Retrieves all of the objects that share a relationship with this agent
* getPredecessors(agent) - Retrieves all of the objects that have a relationship to this agent
* getSuccessors(agent) - Retrieves all of the objects that have a relationship from this agent
* getEdges(agent) - Retrieves all of the edges which have this agent as an endpoint
* getOutEdges(agent) - Retrieves all of the edges which have this agent as a source
* getInEdges(agent) - Retrieves all of the edges which have this agent as a target
* addEdge(agent, agent) - Adds an edge between the two agents
* addEdge(agent, agent, weight) - Adds an edge of the specified weight between the two agents
* addEdge(RepastEdge edge) - Adds the specified edge. Assumes that the source and target of the
edge are part of the network
* getEdge(agent, agent) - Get the edge, if any, between source and target agents</p></div>
<div class="paragraph"><p>In addition to these, there are also many other methods. See the javadoc for Network for more info.</p></div>
</div>
<div class="sect2">
<h3 id="_gis_projections">3.8. GIS Projections</h3>
<div class="paragraph"><p>Repast Simphony&#8217;s GIS support is based on the Geography projection. A Geography is essentially a space
in which agents are associated with a spatial geometry (polygon, point, etc.. Agents are stored by type in
layers within the Geography and agents of the same type must have the same geometry. The geography
can be queried spatially to return all the agents within some particular area. When a geography is
displayed the agents are displayed in typical GIS fashion and represented by their associated geometries.
Repast Simphony uses Geotoolsand the Java Topology Suiteextensively for its GIS support.</p></div>
<div class="paragraph"><div class="title">Creating a Geography</div><p>Creating a geography in repast simphony is similar to creating the other projections. Your agents must
exist in the context in order to exist in the geography, and you want to create the geograhy using a
factory to make sure that it is initialized properly.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>GeographyParameters&lt;Object&gt; params = new GeographyParameters&lt;Object&gt;();
GeographyFactory factory = GeographyFactoryFinder.createGeographyFactory(null);
Geography geography = factory.createGeography("GeograhpyName", context, params);</code></pre>
</div></div>
<div class="paragraph"><p>This should be fairly straightforward. We create a GeographyFactory and the create the Geography with
that, passing the name of the Geography, the associated context, and the GeographyParameters.</p></div>
<div class="paragraph"><div class="title">GeographyParameters</div><p>GeographyParameters can be used to set the "adder" and the CoordinateReferenceSystem for a
Geography.</p></div>
<div class="paragraph"><div class="title">Adders</div><p>The adder controls how any agent added to the context is added to the Geography. The default is a
SimpleAdder which although it makes the Geography aware of the agent, it does not move the agent into
the Geography by associating it with some Geometry. Custom adders can be created by implementing
the GISAdder interface. A typical custom adder would call Geography.move to move an agent into the
Geography and associate it with a Geometry in some model specific manner.</p></div>
<div class="paragraph"><div class="title">CoordinateReferenceSystem</div><p>Using GeographyParameters, you can define the CoordinateReferenceSystem for the created Geography.
In the absence of any user supplied CRS, the default is WGS84 as defined by Geotools'
DefaultGeographicCRS.WGS84. That CRS uses (longitude, latitude) coordinates with longitude
values increasing East and latitude values increasing North. Angular units are degrees and
prime meridian is Greenwich.</p></div>
<div class="paragraph"><div class="title">Moving in a Geography</div><p>Moving a Geography is typically accomplished using the following method</p></div>
<div class="listingblock">
<div class="content">
<pre><code>move(T agent, Geometry geom)</code></pre>
</div></div>
<div class="paragraph"><p>The first time this is called for an agent that agent is moved into the Geography and associated with the
specific geometry. The specific geometry establishes the agent&#8217;s location in the geographical space and
subsequent queries of the Geography will make use of that Geometry. If this is the first time an agent of
this Class has been move in the Geography that type of agent will become associated with that Geometry
type. For example, if the agent&#8217;s type is the Java class anl.model.Truck, and the Geometry is a Point,
then all Trucks are considered to be Points and any Truck moved in the Geography must have a Point
geometry.</p></div>
<div class="paragraph"><p>An agent&#8217;s current Geometry (i.e. its location) can be retrieved with:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Geometry getGeometry(Object agent);</code></pre>
</div></div>
<div class="paragraph"><p>This returned Geometry can be used to move the agent without recreating a Geometry and passing that
new Geometry to the move method. For example, where "this" refers to an agent,</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Geometry geom = geography.getGeometry(this);
Coordinate coord = geom.getCoordinate();
coord.x += .005;
coord.y += .005;
geography.move(this, geom);</code></pre>
</div></div>
<div class="paragraph"><p>In this case, we know the Geometry is a Point and so it has a single coordinate whose x and y values we
can change. Note that its important to call move here to register the move with the Geography.
Geography has additional move methods that can move by displacement etc.:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>/**
* Displaces the specified object by the specified lon and lat amount.
*
* @param object the object to move
* @param lonShift the amount to move longitudinaly
* @param latShift the amount to move latitudinaly
* @return the new geometry of the object
*/
Geometry moveByDisplacement(T object, double lonShift, double latShift);

/**
* Moves the specified object the specified distance along the specified angle.
*
* @param object the object to move
* @param distance the distance to move
* @param unit the distance units. This must be convertable to meters
* @param angleInRadians the angle along which to move
*
* @return the geometric location the object was moved to
*/
Geometry moveByVector(T object, double distance, Unit unit, double angleInRadians);

/**
* Moves the specified object the specified distance along the specified angle.
*
* @param object the object to move
* @param distance the distance to move in meters
* @param angleInRadians the angle along which to move
*
* @return the geometric location the object was moved to
*/
Geometry moveByVector(T object, double distance, double angleInRadians);</code></pre>
</div></div>
<div class="paragraph"><div class="title">Queries</div><p>A Geography can also be queried spatially to return the objects within a particular envelope.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>/**
* Gets an iterable over all the objects within the specified envelope.
*
* @param envelope the bounding envelope
* @return an iterable over all the objects within the specified location.
*/
Iterable&lt;T&gt; getObjectsWithin(Envelope envelope);</code></pre>
</div></div>
<div class="paragraph"><p>Additional queries are available for getting agents that intersect another agent or geometry, for getting
the agents that touch another agent or geometry, and so on. See the classes in the
repast.simphony.query.space.gis package for more information.</p></div>
</div>
<div class="sect2">
<h3 id="_random_numbers">3.9. Random Numbers</h3>
<div class="paragraph"><div class="title">RandomRegistry</div><p>Like many of the other registries in Simphony, the RandomRegistry is available
through the current RunState (through its getRandomRegistry() method). This
interface provides the capability for storing named random distributions and
retrieving them. It also can set and retrieve the seed that a stream will use
(or is using) for streams it creates through its addStream(String, Class, &#8230;)
methods.</p></div>
<div class="paragraph"><div class="title">RandomHelper</div><p>The RandomRegistry by itself is somewhat difficult to work with, to simplify
using it the RandomHelper class was created. This provides methods for creating
the random streams that will be used, and for retrieving the streams after they
have been created, when you do not have a reference to the current RunState.</p></div>
<div class="paragraph"><p>Through its getStream, getUniform and getNormal methods, you can retrieve
distributions from the current RandomRegistry. Through its numerous createXXX
methods, you can create the distributions and store them to the current
RandomRegistry.</p></div>
<div class="paragraph"><p>The RandomHelper also handles creating and maintaining a default Uniform number
stream. This stream is the one used by Repast when it needs a random number, and
is no different then the other Uniform number streams, except that it will
always exist when requested from the RandomHelper (when the simulation is
running). If you wish to use a Uniform distribution for your random numbers, you
can avoid some of the extra work that comes with the named streams (meaning,
specifying the name of the stream, and possibly casting the stream) by simply
using RandomHelpers' getDefault, nextInt, and nextDouble methods. You also can
retrieve and/or set the seed for the default stream through the RandomHelper&#8217;s
getSeed and setSeed methods.</p></div>
<div class="paragraph"><p>Generally there are going to be two types of usage of the random functionality.
The first would be when you just need random numbers of some sort. In this case
you would just want to use RandomHelper&#8217;s default methods, meaning the
getDefault(), nextInt and nextDouble methods.</p></div>
<div class="paragraph"><p>The other case is when you want numbers from a non-Uniform distribution, or you
want multiple random streams functioning at once. In this case you can use
RandomHelper&#8217;s default methods for any uniform numbers, but for producing
multiple streams or a non-Uniform stream you have to use the methods that
take in a stream name. Each of these separate cases will be walked through next.</p></div>
<div class="paragraph"><div class="title">Single Stream Default Use</div><p>When working with the default Uniform stream there is really only one thing you
may want to look at manipulating, the default stream&#8217;s random seed. This is set
through the RandomHelper&#8217;s setSeed(int) method. Setting the random seed should
generally happen when the model is setting up. There are two ways you can do
this. One way is in a ControllerAction, but if you wish to use the random
numbers in setting up the model you will not have your seed set ahead of time.
The other (correct) way is in a ParameterSetter.</p></div>
<div class="paragraph"><p>In the ParameterSetter you are going to want to call RandomHelper&#8217;s setSeed
method, as below:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>public class MySimpleSetter extends SimpleParameterSetter {
        public void next(Parameters params) {
                RandomHelper.setSeed(System.currentTimeMillis());
        }
}</code></pre>
</div></div>
<div class="paragraph"><p>The above code will set the default uniform distribution&#8217;s seed to be the
current time. Now that the time is set, the agents or controller actions (in
their runInitialize methods) can use the default distribution and will recieve
numbers based off of that seed. For example if you had an agent that wanted to
move based on some random condition, that could look like:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>public void agentAction() {
        if (myHappiness &lt; RandomHelper.nextDouble()) {
                move();
        }
}</code></pre>
</div></div>
<div class="paragraph"><p>The above example compares the agent&#8217;s happiness to a random number between 0
and 1, in (0, 1), if the random number is greater than the agent&#8217;s happiness it
will move.</p></div>
<div class="paragraph"><div class="title">Multiple Stream / Non Uniform Stream Usage</div><p>As with the single streams, you generally are going to want to create your
Random number streams when your model is initializing, primarily in a
ParameterSetter, at the point the ParameterSetter will be executed the run&#8217;s
RandomRegistry will be setup, and you can feel free to use the RandomHelper.</p></div>
<div class="paragraph"><p>With these streams you are going to need to consistently use the same stream
name(s) when working with the RandomHelper or the RandomRegistry. You will need
to pass this name into the methods, so that that the helper/registry knows where
to get the values from. For example, let&#8217;s say that you want 2 random number
streams; one a Poisson distribution, and one a Normal distribution. With both of
these using a distinct random seed.</p></div>
<div class="paragraph"><p>So an example initialization would look like:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>public class MySetter extends ParameterSetter {
        public void next(Parameters params) {
                // first create the normal distribution
                // we pass in null so that it will use the current random registry
                RandomHelper.createNormal(null, "MyNormal", normalSeed, 0, 1);
                // next we create the poisson distribution

                RandomHelper.createPoisson(null, "MyPoisson", poissonSeed, 0);
        }
}</code></pre>
</div></div>
<div class="paragraph"><p>The above code created a normal distribution named "MyNormal" that has a mean of
0, a standard deviation of 1, and some seed (normalSeed). It then creates a
poisson distribution named "MyPoisson" with a mean of 0 and some specified seed
(poissonSeed). It is worth noticing however that unlike the default stream, if
you do not setup these streams with the given name they will not be created for
you. You must create them in some way (for instance like above) or you will not
be able to use them.</p></div>
<div class="paragraph"><p>You can then use these distributions from your code. If you wanted to do the
same thing as the single stream example, but with the normal stream you would do:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>public void agentAction() {
        if (myHappiness &lt; RandomHelper.getNormal("MyNormal").nextDouble()) {
                move();
        }
}</code></pre>
</div></div>
<div class="paragraph"><p>The Poisson stream is slightly less straighforward to use, in that direct helper
methods are not provided that will cast the stream to a Poisson distribution.
For this distribution you must cast the stream yourself. This is more
complicated than it sounds, and functions simply like:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>public void agentAction() {
        // grab the distribution with the given name, casting it to a Poisson distribution
        Poisson randomStream = (Poisson) RandomHelper.getStream("MyPoisson");
        // now use it
        if (myHappiness &lt; randomStream.nextDouble()) {
                move();
        }
}</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_scheduling">3.10. Scheduling</h3>
<div class="paragraph"><p>There are basically three ways to work with the Repast Simphony Scheduler. No
one is better than the other and they each have their specified purpose.</p></div>
<div class="paragraph"><div class="title">Directly Schedule an action</div><p>This is similar to the way that actions have always been scheduled in repast
with a slight twist. In this scenario, you get a schedule and tell it the when
and what to run. An example of adding an item to the schedule this way is as
follows:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>//Specify that the action should start at tick 1 and execute every other tick
ScheduleParameters params = ScheduleParameters.createRepeating(1, 2);

//Schedule my agent to execute the move method given the specified schedule parameters.&amp;nbsp;
schedule.schedule(params, myAgent, "move");</code></pre>
</div></div>
<div class="paragraph"><p>The biggest change here is that instead of using one of the numerous methods to
set up the parameters for the action like you would in repast 3, you just use
an instance of ScheduleParameters. ScheduleParameters can be created using one
of several convient factory methods if desired. A slight alteration of this is:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>//Specify that the action should start at tick 1 and execute every other tick
ScheduleParameters params = ScheduleParameters.createRepeating(1, 2);

//Schedule my agent to execute the move method given the specified schedule parameters.
schedule.schedule(params, myAgent, "move", "Forward", 4);</code></pre>
</div></div>
<div class="paragraph"><p>This example schedules the same action with the same parameters, but passes
arguments to the method that is to be called. The "Forward" and 4 will be passed
as arguments to the method move. The assumption is that the signature for move
looks like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>public void move(String direction, int distance)</code></pre>
</div></div>
<div class="paragraph"><div class="title">Schedule with Annotations</div><p>Java 5 introduced several new and exciting features (some of which are used
above), but one of the most useful is Annotation support. Annotations, in java,
are bits of metadata which can be attached to classes, methods or fields that
are available at runtime to give the system more information. Notable uses
outside repast includes the EJB3 spec which allows you to create ejbs using
annotations without requiring such complex descriptors. For repast, we thought
annotations were a perfect match for tying certain types of scheduling
information to the methods that should be scheduled. The typical case where you
would use annotations is where you have actions whose schedule is know at
compile time. So for example, if you know that you want to have the paper
delivered every morning, it would be logical to schedule the deliverPaper()
method using annotations. Without going into extensive documentation about how
annotations work (if you want that look at Java 5 Annotations), here is how you
would schedule an action using annotations:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>@ScheduledMethod(start=1 , interval=2)
public void deliverPaper()</code></pre>
</div></div>
<div class="paragraph"><p>The arguments of the annotation are similar to the properties for the
ScheduleParameters object. One particularly nice feature of using annotations
for scheduling is that you get keep the schedule information right next to the
method that is scheduled, so it is easy to keep track of what is executing when.
Most of the time, objects with annotations will automatically be added to the
schedule, however, if you create a new object while your simulation is running,
this may not be the case. Fortunately, the schedule object makes it very easy to
schedule objects with annoations.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>//Add the annotated methods from the agent to the schedule.
schedule.schedule(myAgent);</code></pre>
</div></div>
<div class="paragraph"><p>The schedule will search the object for any methods which have annotations and
add those methods to the schedule. This type of scheduling is not designed to
handle dynamic scheduling, but only scheduling, where the actions are well
defined at compile time.</p></div>
<div class="paragraph"><div class="title">Schedule with Watcher</div><p>Scheduling using watchers is the most radical of the new scheduling approaches.
Watchers are designed to be used for dynamic scheduling where a typical workflow
is well understood by the model designer. Basically, a watcher allows an agent
to be notified of a state change in another agent and schedule an event to occur
as a result. The watcher is set up using an annotation (like above), but instead
of using static times for the schedule parameters, the user specifies a query
defining whom to watch and a query defining a trigger condition that must be met
to execute the action. That&#8217;s a bit of a mouthfull, so let&#8217;s take a look at an
example to hopefully clarify how this works. (this code is from the
SimpleHappyAgent model which ships with Repast Simphony)</p></div>
<div class="listingblock">
<div class="content">
<pre><code>@Watch(watcheeClassName = "repast.demo.simple.SimpleHappyAgent",
        watcheeFieldName = "happiness", query = "linked_from",
        whenToTrigger = WatcherTriggerSchedule.LATER, scheduleTriggerDelta = 1,
        scheduleTriggerPriority = 0)
public void friendChanged(SimpleHappyAgent friend) {
        if (Math.random() &gt; .25) {
        this.setHappiness(friend.getHappiness());
        } else {
                this.setHappiness(Random.uniform.nextDouble());
        }
        System.out.println("Happiness Changed");
}</code></pre>
</div></div>
<div class="paragraph"><p>There is a fair amount going on in this, so we&#8217;ll parse it out piece by piece.
First, note that there is a @Watch annotation before the method. This tells the
Repast Simphony system that this is going to be watching other objects in order
to schedule the friendChanged() method. The first parameter of the annotation is
the watcheeClassName. This defines the type of agents that this object will be
watching. The second argument, watcheeFieldName, defines what field we are
interested in monitoring. This means that there is a variable in the class
SimpleHappyAgent, that we want to monitor for changes. When it changes, this
object will be notified. The query argument defines which instances of
SimpleHappyAgent we want to monitor. In this case we are monitoring agents to
whom we are linked. For more documentation on arguments for this query can be
found at: Watcher Queries. The whenToTrigger argument specifies whether to
execute the action immediately (before the other actions at this time are
executed) or to wait until the next tick. The scheduleTriggerDelta defines how
long to wait before scheduling the action (in ticks). Finally the
scheduleTriggerPriority allows you to help define the order in which this action
is executed at it&#8217;s scheduled time.</p></div>
<div class="paragraph"><p>Let me give a practical example of how this would be used. Let&#8217;s say you are
modelling electrical networks. You may want to say that if a transformer shuts
down, at some time in the future a plant will shut down. So you make the plant a
watcher of the transformer. The plant could watch a variable called status on
the transformers to which it is connected, and when the transformer&#8217;s status
changes to OFF, then the plant can schedule to shut down in the future. All done
with a single annotation. It could look like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>@Watch(watcheeClassName = "infr.Transformer", watcheeFieldName = "status", query =
        "linked_from", whenToTrigger = WatcherTriggerSchedule.LATER, scheduleTriggerDelta = 1)
public void shutDown(){
        operational = false;
}</code></pre>
</div></div>
<div class="paragraph"><p>Obviously that is a simple example, but it should give you an idea of how to
work with scheduling this way.</p></div>
</div>
<div class="sect2">
<h3 id="_watcher_queries">3.11. Watcher Queries</h3>
<div class="paragraph"><p>Watcher queries are boolean expressions that evaluate the watcher and the
watchee with respect to each other and some projection or context. The context
is the context where the watcher resides and the projections are those contained
by that context. In the following "[arg]" indicates that the arg is optional.</p></div>
<div class="ulist"><ul>
<li>
<p>
colocated - true if the watcher and the watchee are in the same context.
</p>
</li>
<li>
<p>
linked_to [<em>network name</em>] - true if the watcher is linked to the watchee in
any network, or optionally in the named network
</p>
</li>
<li>
<p>
linked_from [<em>network name</em>] - true if the watcher is linked from the watchee
in any network, or optionally in the named network
</p>
</li>
<li>
<p>
within X [<em>network name</em>] - true if the path from the watcher to the watchee
is less than or equal to X where X is a double precision number. This is either
for any network in the context or in the named network.
</p>
</li>
<li>
<p>
within_vn X [<em>grid name</em>] - true if the watchee is in the watcher&#8217;s von
neumann neighborhood in any grid projection or in the named grid. X is the
extent of the neighborhood in the x, y, [z] dimensions.
</p>
</li>
<li>
<p>
within_moore X [<em>grid name</em>] - true if the watchee is in the watcher&#8217;s moore
neighborhood in any grid projection or in the named grid. X is the extent of the
neighborhood in the x, y, [z] dimensions.
</p>
</li>
<li>
<p>
within X [<em>geography name</em>] true if the orthodromic distance from the watcher
to the watchee is less than or equal to X meters, otherwise false. Watcher
queries can be combined using the keywords not and and as well as ( to establish
precedence. For example
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content">
<pre><code>within 2 'family' and not linked_to 'business'</code></pre>
</div></div>
<div class="paragraph"><p>The queries are tested in WatcherQueryTests and defined as annotations in
MyWatcher.</p></div>
</div>
<div class="sect2">
<h3 id="_gui_parameters_and_probes">3.12. GUI Parameters and Probes</h3>
<div class="paragraph"><div class="title">GUI Parameters</div><p>GUI Parameters are the simulation parameters that appear in the parameters view
in the application GUI. These parameters are automatically created from the
parameters XML file or from any @Parameters method annotations that are used in
a Context. At the moment, these two options only allow for the creation of
unconstrained numeric, boolean and String parameters. However, constrained
parameters of more complicated types can be defined using an xml based format.
This section describes how  to save, load and "set as default" parameters using
the parameters tools menu, and the last section looks  at the parameters
returned from agent probes.</p></div>
<div class="paragraph"><div class="title">Convertors and custom parameter types</div><p>Repast Simphony can internally handle the conversion of numeric and boolean
types to and from the Strings in the gui display and the parameter file.
However, if you wish to use a type other than these, then you must provide a
converter that will convert an Object to and from a String representation. A
converter is class that implements StringConverter and is used to create the
appropriate Object from a string representation when reading the xml file and
taking input from the gui. The converter also converts the object to a string
representation. This string is then used when writing the object out and
displaying the parameter&#8217;s value in the gui.</p></div>
<div class="paragraph"><p>For example, supposing you wish use the following Name class as a Parameter.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>package repast.test.viz;public class Name {
        private String first, last;
        private int hashCode;

        public Name(String first, String last) {
                this.first = first;
                this.last = last;
                hashCode = 17;
                hashCode = 37 * hashCode + first.hashCode();
                hashCode = 37 * hashCode + last.hashCode();
        }

        public String getFirst() {
                return first;
        }

        public String getLast() {
                return last;
        }

        public int hashCode() {
                return hashCode;
        }

        public boolean equals(Object obj) {
                if (obj instanceof Name) {
                        Name other = (Name) obj;
                        return other.first.equals(this.first) &amp;&amp; other.last.equals(this.last);
                }
                return false;
        }

        public String toString() {
                return "Name(" + first + ", " + last + ")";
        }
}</code></pre>
</div></div>
<div class="paragraph"><p>Your parameter XML then would look something like:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;parameters&gt; ...
        &lt;parameter name="name" displayName="Full Name" type="repast.test.viz.Name"
                defaultValue="Joe Smith" converter="repast.test.viz.NameConverter" /&gt;
&lt;/parameters&gt;</code></pre>
</div></div>
<div class="paragraph"><p>The type is the fully qualified name of the parameter type (in this case "Name")
and the converter is the fully qualified name of the converter class. The
converter must implement the StringConverter interface. StringConverter has two
methods for converting to and from a String representation.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>package repast.parameter;

/**
* Converts an Object to and from a String representation. Subclasses
* are specialized for specified objects.
*
* @author Nick Collier
*/
public interface StringConverter&lt;T&gt; {

        /**
        * Converts the specified object to a String representation and
        * returns that representation. The representation should be such
        * that &lt;code&gt;fromString&lt;/code&gt; can recreate the Object.
        *
        * @param obj the Object to convert.
        *
        * @return a String representation of the Object.
        */
        String toString(T obj);

        /**
        * Creates an Object from a String representation.
        *
        * @param strRep the string representation
        * @return the created Object.
        */
        T fromString(String strRep);
}</code></pre>
</div></div>
<div class="paragraph"><p>The NameConverter then looks like:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>package repast.test.viz;
import repast.parameter.*;
public class NameConverter implements StringConverter&lt;Name&gt; {

        /**
        * Converts the specified object to a String representation and
        * returns that representation. The representation should be such
        * that &lt;code&gt;fromString&lt;/code&gt; can recreate the Object.
        *
        * @param obj the Object to convert.
        * @return a String representation of the Object.
        */
        public String toString(Name obj) {
                return obj.getFirst() + " " + obj.getLast();
        }

        /**
        * Creates an Object from a String representation.
        *
        * @param strRep the string representation
        * @return the created Object.
        */
        public Name fromString(String strRep) {
                int index = strRep.indexOf(" ");
                String first = strRep.substring(0, index);
                String last = strRep.substring(index + 1, strRep.length());
                return new Name(first, last);
        }
}</code></pre>
</div></div>
<div class="paragraph"><p>It is also possible to use the values attribute to constrain the possible values
of a converted parameter. For example:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;parameters&gt; ...
        &lt;parameter name="name" displayName="Full Name" type="repast.test.viz.Name"
                defaultValue="Joe Smith" converter="repast.test.viz.NameConverter"
                values="'Joe Smith' 'Mary Smith' 'Granny Smith'"/&gt;
&lt;/parameters&gt;</code></pre>
</div></div>
<div class="paragraph"><p>When constraining a converted parameter, the elements in the values list must be
Strings that can be converted using the converter. If you do constrain a
converted parameter in this way, you must override equals (and hashCode) in your
custom type. If not, then the constraint validation will most likely fail.</p></div>
<div class="paragraph"><div class="title">Parameters Panel Tools</div><p>The menu on the parameters panels allows the user to save and load parameter
values, and set the current parameter values as the default.</p></div>
<div class="ulist"><ul>
<li>
<p>
Saving - clicking the save menu item will prompt for a file name and then save
the current parameter values into that file.
</p>
</li>
<li>
<p>
Loading - clicking the load menu item will prompt for a file name and then
load the parameter values from that file into the current parameters. This
assumes that the current parameters are compatible with those being loaded,
that is, that the names and types of parameters in the file match the current
parameters.
</p>
</li>
<li>
<p>
Set as Default - this allows the user to set current parameter values as
defaults such that these values will be used when the simulation is reset.
Clicking this menu item prompts for which parameters to set as defaults and then
sets those as the new defaults.
</p>
</li>
</ul></div>
<div class="paragraph"><div class="title">Agent Probes</div><p>An agent can be probed by clicking on its visual representation in the gui. The
agent&#8217;s parameters will then be displayed in a probe panel. By default, the
displayed parameters are derived from an agent&#8217;s Java bean properties which are
themselves derived from get / set accessor method pairs. For example,</p></div>
<div class="listingblock">
<div class="content">
<pre><code>public class VizAgent {
        ...
        public double getWealth() {
                ...
        }

        public void setWealth(double val) {
                ...
        }
}</code></pre>
</div></div>
<div class="paragraph"><p>This creates a "wealth" parameter. The probe panel will display an entry for
"wealth" whose value is the result of the "getWealth" call. When the user enters
a new value in the "wealth" text field then the setWealth method will passed
this new value. Read-only parameters can be created by specifying only a
get-style method. The label for this field will be the simple java bean
properties name. Which properties are treated as parameters, and how to display
them can be further refined by adding an @Parameter annotation to either the
getter or setter of a property method pair. (The information in the annotation
applies equally to both methods.) Using a Parameter annotation, a more
descriptive display name can be specified. For example:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>public class VizAgent {
        ...
        @Parameter(usageName="wealth", displayName="Agent Wealth (in Euros)")
        public double getWealth() {
                ...
        }

        public void setWealth(double val) {
                ...
        }
}</code></pre>
</div></div>
<div class="paragraph"><p>The usageName should correspond to the java bean property which is typically the
method name minus the get/set with the first character lower-cased. The
displayName specifies the gui label for this parameter in the probe window.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/note.png" alt="Note" />
</td>
<td class="content">If any method is annotated with @Parameter, then only @Parameter annotated
methods will be displayed in the probe panel.</td>
</tr></table>
</div>
<div class="paragraph"><p>Using the @Parameter annotation, you can also specify the name of a converter to
convert to and from a displayable String. By specifying a converter, any type of
object contained by the agent can be displayed as a parameter. This converter is
identical that described above in the extended parameters section. See the
convertors and custom parameter types section above for more details. For
example,</p></div>
<div class="listingblock">
<div class="content">
<pre><code>public class VizAgent {
        ...
        @Parameter(usageName="wealth", displayName="Agent Wealth (in Euros)",
                converter="repast.demo.MoneyConverter")
        public Money getWealth() {
                ...
        }

        public void setWealth(Money val) {
                ...
        }
}</code></pre>
</div></div>
<div class="paragraph"><p>In this case, the agent&#8217;s wealth is represented by a Money class and a
MoneyConverter is used to convert to and from a String value. Lastly, by default
the probe&#8217;s title will be the result of calling "toString()" on the probed
object (e.g. <a href="mailto:VizAgent@55927f">VizAgent@55927f</a>, in the above screen shot). A more appropriate
title can be specified either by overriding toString() and returning the desired
value, or annotating any method that returns the desired title with @ProbeID.
For example:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>public class VizAgent {
        ...
        @ProbeID
        public String name() { return name;}

        @Parameter(usageName="wealth", displayName="Agent Wealth (in Euros)",
                converter="repast.demo.MoneyConverter")
        public Money getWealth() {
                ...
        }

        public void setWealth(Money val) {
                ...
        }
}</code></pre>
</div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_batch_runs">4. Batch Runs</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_batch_parameters">4.1. Batch Parameters</h3>
<div class="paragraph"><p>Repast Simphony supports the creation of a parameter sweep through an xml file or through a scripted
bsf file. Both define a sweep through the defintion of parameter setters. These setters may be constant
setters such that the parameter value remains at its initial value, or the setters may define a list of values
to sweep through, or lastly the setter may function as a numeric stepper that incrementally steps from an
initial value through some ending value. These setters are organized in tree such that the sweep defined
by a child is fully iterated through before the parent is incremented.</p></div>
<div class="paragraph"><div class="title">Parameter XML file</div><p>Individual parameters are identified as parameter elements and have two required attributes: name
and type.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;parameter name="parameter_1" type=["number", "list", "constant"] ... /&gt;</code></pre>
</div></div>
<div class="ulist"><ul>
<li>
<p>
name is the name of the parameter. The current value of the parameter can be retrieved from the
Parameters object using this name.
</p>
</li>
<li>
<p>
type identifies the how the value of the parameter will be set over the course of subsequent batch
runs. Depending on the type, the parameter element will have additional attributes.
</p>
</li>
</ul></div>
<div class="paragraph"><div class="title">Parameter Types</div><p>Currently 3 types of parameters are supported.</p></div>
<div class="ulist"><ul>
<li>
<p>
number&#8201;&#8212;&#8201;the number type defines a parameter space with a starting, ending and step value. The
sweep mechanism will sweep through the space defined by these values by incrementing the
starting value with the step value until the ending value is reached. For example,
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;parameter name="num_1" type="number" start="1" end="4" step="1"/&gt;</code></pre>
</div></div>
<div class="paragraph"><p>will start with a value of 1 and increment by 1 until 4 is reached. The type of number (long, double,
float and integer) is inferred from the start, end and step values. If any of the values ends with <em>f</em>,
for example</p></div>
<div class="listingblock">
<div class="content">
<pre><code>4f or 3.21f</code></pre>
</div></div>
<div class="paragraph"><p>the parameter will be of the float type. Similarly, if any of the values end with <em>L</em>, the type will be a
long. In the absence of a "f" suffix, if any of the numeric values contain a decimal point and one or
more digits (e.g. 4.0) then the type will be a double. Otherwise, the type will be int.</p></div>
<div class="ulist"><ul>
<li>
<p>
list&#8201;&#8212;&#8201;the list type defines a parameter space as a list.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;parameter name="list_val" type="list" value_type=["string", "boolean", "double", "int",
"long", "float"] values="x y z"/&gt;</code></pre>
</div></div>
<div class="paragraph"><p>The sweeper will iterate through the values in the list setting the parameter to that value.The
value_type attribute defines the type of the list elements and can be one of string, boolean,
double, int, long, float. Elements are delimited by a blank space. String elements can be surrounded
by single quotes (') if they contain blank space. For example,</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;parameter name="list_val" type="list" value_type="string" values="'foo bar' 'bar' 'baz'"/&gt;
defines 3 elements foo bar, bar and baz.</code></pre>
</div></div>
<div class="ulist"><ul>
<li>
<p>
constant&#8201;&#8212;&#8201;constant types define a parameter space consisting of a single constant value.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;parameter name="const_1" type="constant" constant_type=["number", "boolean", "string"]
value="x"/&gt;</code></pre>
</div></div>
<div class="paragraph"><p>The sweeper will set the parameter to this constant value. The constant_type attribute defines the
type of the constant value. A constant type of "number" works as its does above where the specified
type of number (float and so forth) is derived from the value itself.</p></div>
<div class="paragraph"><div class="title">Nesting Parameters</div><p>Parameters can be nested such that the space defined by the child or nested parameter will be swept
before incrementing any values in the parent parameter at which point the child will be reset to its
starting value. For example,</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;parameter name="numAgents" type="number" start="1000" end="2000" step="10"&gt;
        &lt;parameter name="wealth" type="list" value_type="float" values="10.1 12.3 1234.23 23" /&gt;
&lt;/parameter&gt;</code></pre>
</div></div>
<div class="paragraph"><p>In this case, the sweeper will do set numAgents to 1000 and then sweep through each of the the wealth
values. Then it will increment numAgents to 1010, and sweep through all the wealth values. It will
continue in this fashion until numAgents reaches its end value. In this way, the simulation is run such
that all the combinations of numAgents and wealth values are explored.</p></div>
<div class="paragraph"><div class="title">Random Seed Parameter</div><p>The default random seed (i.e. the seed for the default random stream) can be specified in a parameter
file using a number type parameter with a name of "randomSeed". For example,</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;parameter name="randomSeed" type="number" start="1" end="4" step="1"/&gt;</code></pre>
</div></div>
<div class="paragraph"><p>If no such parameter exists, the batch mechanism will set the random seed to the current time in
milliseconds.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/note.png" alt="Note" />
</td>
<td class="content">This seed will then be used for all the batch runs, that is, each batch run
will use the same random seed.</td>
</tr></table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_advanced_topics">5. Advanced Topics</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_adding_controller_actions">5.1. Adding Controller Actions</h3>
<div class="paragraph"><p>Controller actions can be added and integrated into the controller tree via
plugin extension points. The repast.simphony.core plugin defines the following:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;extension-point id="composite.action"&gt;
        &lt;parameter-def id="creatorClass"/&gt;
&lt;/extension-point&gt;
&lt;extension-point id="component.action"&gt;
        &lt;parameter-def id="actionIO"/&gt;
&lt;/extension-point&gt;</code></pre>
</div></div>
<div class="ulist"><ul>
<li>
<p>
"composite.action" is used to create a parent controller action, that is, a controller action that is
composed of child controller actions. The value of the "creatorClass" parameter must be the name of
a class that implements the CompositeControllerActionCreator interface.
</p>
</li>
<li>
<p>
"component.action" is used to create child or component controller actions that are leaves in the
controller action tree. The value of the "actionIO" parameter must the name of a class that
implements the ControllerActionIO interface. This class is primarily responsible for serializing and
deserializing (saving and loading) a specific type of controller action. For example, the
CNDataLoaderControllerActionIO class is responsible for serializing and deserializing the class name
data loader action.
</p>
</li>
</ul></div>
<div class="paragraph"><p>The repast.simphony.gui plugin extends these two extension points with:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;extension-point id="composite.action" parent-plugin-id="repast.simphony.core" parent-point-id="composite.action"&gt;
        &lt;parameter-def id="label"/&gt;
&lt;/extension-point&gt;
&lt;extension-point id="component.action" parent-plugin-id="repast.simphony.core" parent-point-id="component.action"&gt;
        &lt;parameter-def id="editorCreator"/&gt;
        &lt;parameter-def id="parentMenuItem" multiplicity="none-or-one"/&gt;
        &lt;parameter-def id="parentID"/&gt;
&lt;/extension-point&gt;</code></pre>
</div></div>
<div class="paragraph"><p>These extend the above by adding gui related parameters.
* composite.action adds a label parameter the value of which will be the label for the parent action as
it is displayed in the controller action tree.</p></div>
<div class="ulist"><ul>
<li>
<p>
component.action adds 3 new parameters
</p>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
editorCreator. The value of this parameter is a class that implements the ActionEditorCreator
interface. The editor created by the class that implements this interface will be used to create a
gui editor for editing this action.
</p>
</li>
<li>
<p>
parentMenuItem. The value of this parameter is a class that implements the EditorMenuItem.
This will create the item in the parent menu that allows actions of this type to be created.
</p>
</li>
<li>
<p>
parentID. this is the id of the parent of this controller action.Default parent ids are defined in
repast.plugin.ControllerActionConstants:
</p>
</li>
</ol></div>
</li>
</ul></div>
<div class="listingblock">
<div class="content">
<pre><code>String VIZ_ROOT = "repast.controller.action.viz";
String DATA_LOADER_ROOT = "repast.controller.action.data_loaders";
String SCHEDULE_ROOT = "repast.controller.action.schedule";
String OUTPUTTER_ROOT = "repast.controller.action.outputters";
String GRAPH_ROOT = "repast.controller.action.graphs";
String REPORT_ROOT = "repast.controller.action.reports";
String DATA_SET_ROOT = "repast.controller.action.data_sets";</code></pre>
</div></div>
<div class="paragraph"><p>All the controller actions in repast simphony are added via this mechanism so examining their plugin.xml
files and related code is a good place to learn more.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_developer_topics">6. Developer Topics</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_creating_a_dynamic_wizard">6.1. Creating a Dynamic Wizard</h3>
<div class="paragraph"><p>I&#8217;ve made a wizard framework that dynamically loads its options based on
"options" specified in plugin.xmls. I&#8217;ve used it in enough places that I&#8217;ve gone
ahead and generalized it. If you wish to use this setup I made it fairly
straightforward. The classes used in this are in the repast.simphony.plugin.util
plugin and in the repast.simphony.plugin.wizard package. These classes are
WizardOption and WizardPluginUtil, DynamicWizard, and some related to the
wizard&#8217;s model (DynamicWizardModel, WizardModelFactory).</p></div>
<div class="paragraph"><div class="title">WizardOption</div><p>WizardOption represents an option that will be taken in a wizard. It contains a SimplePath (the GUI steps
the wizard will take) and some description methods (for grabbing the title and description of the option).
Generally someone will subclass/subinterface this interface with their own type (say MyWizardOption) and
add any extra methods to it.
Implementations of WizardOption (or MyWizardOption) would generally specify their description (to be in
tooltips or a description field in the wizard option selection) and a title (for the option&#8217;s title in a "Choose
type" list), and then fill in the other methods as needed.
The implementation would also build the steps it needs (say select file name or select agent class steps)
in getWizardPath and return them.</p></div>
<div class="paragraph"><div class="title">WizardPluginUtil</div><p>The only method in WizardPluginUtil is the only one needed to dynamically load up the wizard options.
This takes in the plugin id, the extension point id where wizard options would be registered, the specific
WizardOption class the options should be an instance of, a PluginManager that the extension points would
be grabbed from, and finally a boolean parameter that specifies whether or not to register the options
with the DynamicWizard (this is important for using the DynamicWizard, and generally should be true).
This assumes the extension point will have a class field specified in it, so it could look like so:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;extension-point id="repast.simphony.data.mappingwizard.options"&gt;
        &lt;parameter-def id="class"/&gt;
&lt;/extension-point&gt;</code></pre>
</div></div>
<div class="paragraph"><p>Or alternatively, you can just create a new extension point inherting its properties off the default one:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;extension-point id="wizard.options" parent-plugin-id="repast.simphony.plugin.util"
        parent-point-id="wizard.options"&gt;
&lt;/extension-point&gt;</code></pre>
</div></div>
<div class="paragraph"><p>And extensions would then look like (assuming the plugin id is repast.simphony.data)</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;extension plugin-id="repast.simphony.data"
        point-id="repast.simphony.data.mappingwizard.options" id="data.bsf.basicoption"&gt;
        &lt;parameter id="class" value="repast.data.bsf.gui.BasicScriptOption"/&gt;
&lt;/extension&gt;</code></pre>
</div></div>
<div class="paragraph"><div class="title">Loading the options</div><p>To load these options you have to call the WizardPluginUtil method from some point where you have
access to the PluginManager. For now the best way to do this is from a menu or other item action
creator. Hopefully at some point a more generic method will exist. You then can store the loaded options
somewhere so that you can have direct access to them if you desire. So for instance this could look like</p></div>
<div class="listingblock">
<div class="content">
<pre><code>public void init(PluginManager manager) {
        // grab all the available wizard options
        List&lt;DataLoaderWizardOption&gt; options = WizardPluginUtil.loadWizardOptions(manager,
                DataLoaderWizardOption.class, PACKAGE_ID, WIZARD_OPTIONS_ID, true);

        // store them for later
        staticOptions = options;
}</code></pre>
</div></div>
<div class="paragraph"><div class="title">Creating the wizard</div><p>Finally, to actually display a wizard that uses these options you use DynamicWizard. There are a lot of
arguments in the DynamicWizard as of now, so it is best to wrap the creation of the wizards in some
other static method. So an example method could look like:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>public static DynamicWizard create(Scenario scenario, Object contextID) {
        return new DynamicWizard(WIZARD_OPTIONS_ID, scenario, contextID, "Select Data Source
                Type", "Choose a type for your data source.", new WizardFinishStep(),
                new WizardModelFactory() {
                        public DynamicWizardModel create(BranchingPath path, Scenario scenario, Object contextID) {
                                return new ChartWizardModel(path, scenario, contextID);
                        }
                }
        );
}</code></pre>
</div></div>
<div class="paragraph"><p>This will create a wizard that has its options stored with the key WIZARD_OPTIONS_ID, scenario and
contextID (just general properties), the specified title for the wizard&#8217;s select an option step, and specified
prompt for that same step, a final "wizard has completed" step, and a factory for generating the model
used by the wizard (in this case a ChartWizardModel).</p></div>
<div class="paragraph"><p>Each of these properties plays their own role in the wizard process. Explicitly, the important ones and
their function (from this example):</p></div>
<div class="ulist"><ul>
<li>
<p>
the wizard id (WIZARD_OPTIONS_ID) - a String that is the extension point id that the wizard
options would have been registered under. This in general is just the wizard&#8217;s ID, meaning, the id
the wizard options would have been registered to WizardPluginUtil&#8217;s methods, but if you set the
register flag to true when using loadWizardOptions, it will store the options with the extension point
id as the wizard id.
</p>
</li>
<li>
<p>
the wizard model factory - This should build the wizard model that the wizard will pass along to each
of the steps. In general this model should be where each step stores their final information. So if
one step is in charge of specifying the directory some action will point to, it should when its done (in
its applyState method) set this directory on the model. The model itself can be grabbed during the
step&#8217;s init(WizardModel) call, which occurs when the step is displayed. This model is important so
that when the wizard has completed you can load the settings that were specified in the wizard
steps (as needed).
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_enabling_freezedrying_of_custom_projections">6.2. Enabling FreezeDrying of Custom Projections</h3>
<div class="paragraph"><p>When building a new Projection, some things should be done if it is to be integrated into the whole
system. In particular, if it is to be freeze dryable, some special considerations may need to be made.
Since the freeze dryer generally just writes out all the fields of an object, this may or may not function
properly for a given Projection.
For a projection to be properly freeze dryed one of the following has to happen:</p></div>
<div class="ulist"><ul>
<li>
<p>
The Projection and all the objects it contains should have a default constructor, or all of its
constructors should be able to support taking in dummy (or null) values. In general, this means the
Projection should be able to be written out and read in with the default freeze dryer
(DefaultFreezeDryer).
</p>
</li>
<li>
<p>
A custom FreezeDryer should be written that will handle the given projection class. This freeze dryer
should be able to read and write the default implementation of your projection, and if reasonable,
other implementations.
</p>
</li>
<li>
<p>
A ProjectionDryer should be created. This is not a FreezeDryer, but is an interface used by the
Context FreezeDryer. Building one of these is discussed below.
</p>
</li>
</ul></div>
<div class="paragraph"><div class="title">Building a ProjectionDryer</div><p>All a ProjectionDryer does is store the settings from a custom Projection into a map, and later rebuild a
projection from a map (with the same settings). Implementations store properties in the addProperties
method, rebuild the projection in instantiate, and restore properties in the loadProperties methods.</p></div>
<div class="paragraph"><div class="title">addProperties</div><p>The addProperties method should add implementation specific properties to the passed in Map. For
instance, in a Network these properties could be a list of edges in the network. This would be something
of the form "edges"&#8594;node1. So it would be
implemented by:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>protected void addProperties(Context context, MyNetwork net, Map&lt;String, Object&gt; properties) {
        super.addProperties(context, net, properties);
        ArrayList list = new ArrayList();
        for (Edge edge : net.getEdges()) {
                list.add(new Object[] { edge.getSource(), edge.getTarget(), edge.getWeight()});
        }
        properties.put("edges", list);
}</code></pre>
</div></div>
<div class="paragraph"><p>The super call lets the class&#8217;s superclass (assuming it is not ProjectionDryer) add any neccessary
properties. It then builds a list of the edges, storing the properties in an array. Finally it stores to the
properties map the list of edges.</p></div>
<div class="paragraph"><div class="title">instantiate and loadProperties</div><p>At some later point the context will be rehydrated and the projection will need to be rehydrated. First the
projection will need to be instantiated, and accordingly, the instantiate method would be called. For our
MyNetwork class this may be something like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>protected T instantiate(Context&lt;?&gt; context, Map&lt;String, Object&gt; properties) {
        String name = (String) properties.get(NAME_KEY);
        return new MyNetwork(name);
}</code></pre>
</div></div>
<div class="paragraph"><p>This simply fetches the projection&#8217;s name (which will be stored in ProjectionDryer&#8217;s loadProperties method
- another reason why it&#8217;s important to call the super&#8217;s method!) and then creates the network with that
name. Next the network&#8217;s properties need to be loaded, which, according to our addProperties method
will be like so:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>protected void loadProperties(Context&lt;?&gt; context, MyNetwork net, Map&lt;String, Object&gt;
properties) {
super.loadProperties(context, proj, properties);
ArrayList&lt;Object[]&gt; edges = (ArrayList&lt;Object[]&gt;) properties.get("edges");
for (Object[] edgeProperties : edges) {
net.addEdge(edgeProperties[0], edgeProperties[1], (Double) edgeProperties[2]);
}
}</code></pre>
</div></div>
<div class="paragraph"><p>In this method we first are calling the super&#8217;s load properties method (so that things like listeners and
any other settings will be loaded), then we fetch the edge information from the properties map (the
ArrayList&#8230; = line), and finally we add the edges into the given network. Note that we may have to cast
the properties if the network requires specific types in its methods (for instance if the weight is a Double
or double as in this example). Now the Projection will be added into the context and the rehydration process will continue on.</p></div>
<div class="paragraph"><div class="title">Registering the new dryer</div><p>The different kind of dryers need to be registered in different kinds of ways. If you create a custom
FreezeDryer, you must register that dryer to any FreezeDryer instance you create. If you have created a
custom ProjectionDryer, you must register it to the ProjectionDryer class by calling its addProjectionDryer
method.</p></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated 2017-10-23 15:41:36 Central Daylight Time
</div>
</div>
</body>
</html>
